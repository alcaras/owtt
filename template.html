<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Old World Tech Tree</title>
    <script src="https://cdn.jsdelivr.net/npm/leader-line@1.0.7/leader-line.min.js"></script>
    <link rel="stylesheet" href="styles.css">

</head>
<body>
    <div class="main-container">
        <div class="tech-tree-wrapper">
            <div class="tech-cost-headers">
                <div class="tech-cost-header">80 🧪</div>
                <div class="tech-cost-header">120 🧪</div>
                <div class="tech-cost-header">200 🧪</div>
                <div class="tech-cost-header">400 🧪</div>
                <div class="tech-cost-header">600 🧪</div>
                <div class="tech-cost-header">1000 🧪</div>
                <div class="tech-cost-header">1600 🧪</div>
                <div class="tech-cost-header">2000 🧪</div>
            </div>
            <div class="tech-tree" id="techTree"></div>
            
            <div class="bonus-tech-section">
                <h3>💎 Bonus Cards</h3>
                <div class="bonus-tech-grid" id="bonusTechGrid"></div>
            </div>
        </div>
    </div>

    <!-- Mobile Stats Bar (visible when sidebar collapsed) -->
    <div class="mobile-stats-bar" id="mobileStatsBar">
        <div class="total-cost" id="totalCostMobile">0 🧪</div>
        <div class="total-laws" id="totalLawsMobile">Laws: 0</div>
    </div>

    <div class="sidebar" id="sidebar">
        <!-- Sidebar Toggle Button -->
        <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">
            <span class="toggle-icon" id="toggleIcon">▶</span>
        </button>
        <button class="mobile-close-button" onclick="toggleSidebar()">×</button>
        
        <div class="sidebar-stats">
            <div class="total-cost" id="totalCost">0 🧪</div>
            <div class="total-laws" id="totalLaws">Laws: 0</div>
        </div>
        
        <div class="sidebar-scrollable">
            <div class="share-section">
                <button class="share-button" onclick="shareBuild()">Share Build</button>
            </div>
            
            <div class="nation-section">
                <h2>Nation</h2>
                <select class="nation-select" id="nationSelect" onchange="selectNation()">
                    <option value="">No Nation</option>
                    <option value="NATION_AKSUM">Aksum</option>
                    <option value="NATION_ASSYRIA">Assyria</option>
                    <option value="NATION_BABYLONIA">Babylonia</option>
                    <option value="NATION_CARTHAGE">Carthage</option>
                    <option value="NATION_EGYPT">Egypt</option>
                    <option value="NATION_GREECE">Greece</option>
                    <option value="NATION_HITTITE">Hittites</option>
                    <option value="NATION_KUSH">Kush</option>
                    <option value="NATION_PERSIA">Persia</option>
                    <option value="NATION_ROME">Rome</option>
                </select>
            </div>
            
            <h2>Research Order</h2>
            <div class="tech-order-list" id="techOrderList"></div>
        </div>
        
        <div class="sidebar-actions">
            <div class="desktop-button-group">
                <button class="simulate-button" onclick="openSimulationPanel()">🎲 Simulate Research</button>
                <button class="redo-button" onclick="redoLastAction()" style="display: none;">Redo</button>
                <button class="undo-button" onclick="undoLastAction()">Undo</button>
                <button class="clear-button" onclick="clearBuild()">Clear All</button>
            </div>
            
            <div class="mobile-button-row">
                <button class="simulate-button" onclick="openSimulationPanel()">🎲</button>
                <button class="undo-button" onclick="undoLastAction()">Undo</button>
                <button class="redo-button" onclick="redoLastAction()" style="display: none;">Redo</button>
                <button class="clear-button" onclick="clearBuild()">Clear</button>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Simulation Panel -->
    <div class="simulation-overlay" id="simulationOverlay" onclick="closeSimulationPanel()"></div>
    <div class="simulation-panel" id="simulationPanel">
        <button onclick="closeSimulationPanel()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; color: var(--primary-gold); font-size: 24px; cursor: pointer; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background 0.2s;" onmouseover="this.style.background='rgba(212, 175, 55, 0.2)'" onmouseout="this.style.background='none'">×</button>
        
        <h3>🎲 Research Simulation Comparison</h3>
        <p style="color: #f4e4c1; margin-bottom: 15px; text-align: center; font-size: 0.9em;">
            Running 1000 simulations for each Scholar/Oracle combination to compare variance in research costs.
        </p>
        
        <div class="simulation-comparison" id="simulationResults">
            <div class="comparison-loading" id="simulationLoading" style="display: none;">
                🔄 Running simulations... This may take a few moments.
            </div>
            <table class="comparison-table" id="comparisonTable">
                <thead>
                    <tr>
                        <th>Configuration</th>
                        <th>Min Cost</th>
                        <th>Max Cost</th>
                        <th>Average Cost</th>
                        <th>Std Dev</th>
                        <th>Expected Range</th>
                    </tr>
                </thead>
                <tbody id="comparisonResults">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Complete tech tree data from game files with correct prerequisites and unlocks
        {{TECH_DATA}}

        let researchedTechs = [];
        let researchOrder = [];
        let researchedBonusTechs = [];
        let completedTechs = []; // Tracks which techs have been marked as completed
        let selectedNation = '';
        let undoHistory = []; // Track actions for undo functionality
        let redoHistory = []; // Track actions for redo functionality
        const MAX_UNDO_HISTORY = 20; // Limit undo history
        const MAX_REDO_HISTORY = 20; // Limit redo history

        // localStorage functions
        function saveToLocalStorage() {
            const state = {
                researchedTechs: researchedTechs,
                researchOrder: researchOrder,
                researchedBonusTechs: researchedBonusTechs,
                completedTechs: completedTechs,
                selectedNation: selectedNation,
                timestamp: Date.now()
            };
            localStorage.setItem('owtt-state', JSON.stringify(state));
        }

        function loadFromLocalStorage() {
            try {
                const stored = localStorage.getItem('owtt-state');
                if (stored) {
                    const state = JSON.parse(stored);
                    
                    // Restore state
                    researchedTechs = state.researchedTechs || [];
                    researchOrder = state.researchOrder || [];
                    researchedBonusTechs = state.researchedBonusTechs || [];
                    completedTechs = state.completedTechs || [];
                    selectedNation = state.selectedNation || '';
                    
                    // Update UI
                    if (selectedNation) {
                        const select = document.getElementById('nationSelect');
                        if (select) {
                            select.value = selectedNation;
                        }
                    }
                    
                    console.log('Loaded state from localStorage:', state);
                    return true;
                }
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
            }
            return false;
        }

        function clearLocalStorage() {
            localStorage.removeItem('owtt-state');
        }

        // Nation lookup array for URL indices
        const nationLookup = [
            "NATION_AKSUM",
            "NATION_ASSYRIA", 
            "NATION_BABYLONIA",
            "NATION_CARTHAGE",
            "NATION_EGYPT",
            "NATION_GREECE",
            "NATION_HITTITE",
            "NATION_KUSH",
            "NATION_PERSIA",
            "NATION_ROME"
        ];

        {{NATION_DATA}}

        function initializeTechTree() {
            const techTree = document.getElementById('techTree');
            techTree.innerHTML = '';
            
            // Add tech nodes
            techData.techs.forEach(tech => {
                const node = document.createElement('div');
                node.className = 'tech-node';
                node.id = tech.id;
                node.style.gridColumn = tech.column + 1;
                node.style.gridRow = tech.row + 1;
                
                // Build unlocks display with emojis
                let unlocksHtml = '';
                const allUnlocks = [];
                
                if (tech.unlocks.units?.length > 0) {
                    tech.unlocks.units.forEach(unit => {
                        allUnlocks.push(`<span class="unlock-item">⚔️${unit}</span>`);
                    });
                }
                if (tech.unlocks.improvements?.length > 0) {
                    tech.unlocks.improvements.forEach(improvement => {
                        // Only show Kushite Pyramids if Kush is selected
                        if (improvement === "Kushite Pyramids" && selectedNation !== "NATION_KUSH") {
                            return;
                        }
                        allUnlocks.push(`<span class="unlock-item">🏗️${improvement}</span>`);
                    });
                }
                if (tech.unlocks.laws?.length > 0) {
                    tech.unlocks.laws.forEach(law => {
                        allUnlocks.push(`<span class="unlock-item">⚖️${law}</span>`);
                    });
                }
                if (tech.unlocks.projects?.length > 0) {
                    tech.unlocks.projects.forEach(project => {
                        allUnlocks.push(`<span class="unlock-item">🏛️${project}</span>`);
                    });
                }
                
                // Check if this tech has bonus techs available and add to unlocks
                const bonusTechs = techData.bonusTechs.filter(bonus => {
                    if (bonus.parent !== tech.id) return false;
                    // Only show nation-specific bonus cards if that nation is selected
                    if (bonus.nation && bonus.nation !== selectedNation) return false;
                    return true;
                });
                if (bonusTechs.length > 0) {
                    bonusTechs.forEach(bonusTech => {
                        // Use person emoji for courtiers, diamond for others
                        const isCourtier = bonusTech.name.includes('Minister') || 
                                         bonusTech.name.includes('Scientist') || 
                                         bonusTech.name.includes('Court Soldier') ||
                                         bonusTech.name.includes('Merchant');
                        const emoji = isCourtier ? '👤' : '💎';
                        allUnlocks.push(`<span class="unlock-item">${emoji}${bonusTech.name}</span>`);
                    });
                }
                
                if (allUnlocks.length > 0) {
                    unlocksHtml = `<div class="tech-unlocks">${allUnlocks.join('')}</div>`;
                }
                
                node.innerHTML = `
                    <div class="tech-name">${tech.name}</div>
                    ${unlocksHtml}
                `;
                
                node.addEventListener('click', () => toggleResearch(tech.id));
                node.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    quickToggleCompletion(tech.id);
                });
                node.addEventListener('mouseenter', (e) => {
                    showTooltip(e, tech);
                    showPrerequisitePreview(tech.id);
                });
                node.addEventListener('mouseleave', () => {
                    hideTooltip();
                    clearPrerequisitePreview();
                });
                
                techTree.appendChild(node);
            });
            
            // Initialize bonus tech section
            initializeBonusTechs();
            
            // Load state: URL params take priority over localStorage
            const urlParams = new URLSearchParams(window.location.search);
            const hasUrlParams = urlParams.has('n') || urlParams.has('nation') || urlParams.has('t') || urlParams.has('techs') || urlParams.has('b') || urlParams.has('bonus');
            
            if (hasUrlParams) {
                // Load from URL if present (for sharing links)
                loadFromUrl();
                // Clear URL params after loading so future reloads use localStorage
                window.history.replaceState({}, document.title, window.location.pathname);
            } else {
                // Load from localStorage if no URL params
                loadFromLocalStorage();
            }
            
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            updateUndoRedoButtons(); // Initialize undo/redo button states
        }

        function initializeBonusTechs() {
            const bonusTechGrid = document.getElementById('bonusTechGrid');
            bonusTechGrid.innerHTML = '';
            
            // Filter bonus techs based on selected nation
            const availableBonusTechs = techData.bonusTechs.filter(bonusTech => {
                // Show general bonus techs (no nation property)
                if (!bonusTech.nation) return true;
                // Show nation-specific bonus techs only if nation is selected and matches
                return selectedNation && bonusTech.nation === selectedNation;
            });
            
            // Group bonus techs by cost
            const costGroups = {};
            availableBonusTechs.forEach(bonusTech => {
                if (!costGroups[bonusTech.cost]) {
                    costGroups[bonusTech.cost] = [];
                }
                costGroups[bonusTech.cost].push(bonusTech);
            });
            
            // Sort cost groups by cost
            const sortedCosts = Object.keys(costGroups).map(Number).sort((a, b) => a - b);
            
            sortedCosts.forEach(cost => {
                // Create cost group container
                const costGroup = document.createElement('div');
                costGroup.className = 'bonus-cost-group';
                
                // Add cost header  
                const costHeader = document.createElement('div');
                costHeader.className = 'bonus-cost-header';
                costHeader.textContent = `${cost} 🧪`;
                costGroup.appendChild(costHeader);
                
                // Add cards column
                const cardsColumn = document.createElement('div');
                cardsColumn.className = 'bonus-cards-column';
                
                costGroups[cost].forEach(bonusTech => {
                    const node = document.createElement('div');
                    node.className = 'bonus-tech-node';
                    node.id = bonusTech.id;
                    
                    node.innerHTML = `
                        <div class="bonus-tech-name">${bonusTech.name}</div>
                        <div class="bonus-tech-parent">${bonusTech.bonus}</div>
                    `;
                    
                    node.addEventListener('click', () => toggleBonusResearch(bonusTech.id));
                    node.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        quickToggleBonusCompletion(bonusTech.id);
                    });
                    node.addEventListener('mouseenter', (e) => showBonusTooltip(e, bonusTech));
                    node.addEventListener('mouseleave', hideTooltip);
                    
                    cardsColumn.appendChild(node);
                });
                
                costGroup.appendChild(cardsColumn);
                bonusTechGrid.appendChild(costGroup);
            });
            
            updateBonusTechStates();
        }

        function toggleBonusResearch(bonusTechId) {
            const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
            if (!bonusTech) return;

            // Save state before changes for undo
            const previousBonusTechs = researchedBonusTechs.slice();
            const previousTechs = researchedTechs.slice();
            const previousOrder = researchOrder.slice();
            const previousCompleted = completedTechs.slice();

            const index = researchedBonusTechs.indexOf(bonusTechId);
            if (index > -1) {
                // Remove bonus tech
                researchedBonusTechs.splice(index, 1);
                // Also remove from completed techs
                const completedIndex = completedTechs.indexOf(bonusTechId);
                if (completedIndex > -1) {
                    completedTechs.splice(completedIndex, 1);
                }
                
                // Record action for undo
                recordAction('removeBonusTech', {
                    bonusTechName: bonusTech.name,
                    previousBonusTechs: previousBonusTechs,
                    previousCompleted: previousCompleted
                });
            } else {
                // Add the parent tech and all its prerequisites first
                if (!researchedTechs.includes(bonusTech.parent)) {
                    // Add prerequisites of the parent tech using proper insertion order
                    const prereqsToAdd = getAllPrerequisites(bonusTech.parent);
                    prereqsToAdd.forEach(prereqId => {
                        if (!researchedTechs.includes(prereqId)) {
                            // Find the correct insertion point to maintain tech tree order
                            const insertIndex = findInsertionIndex(prereqId);
                            researchedTechs.splice(insertIndex, 0, prereqId);
                            researchOrder.splice(insertIndex, 0, Date.now() - (prereqsToAdd.length - prereqsToAdd.indexOf(prereqId)) * 1000);
                        }
                    });
                    
                    // Add the parent tech itself in the correct position
                    const parentInsertIndex = findInsertionIndex(bonusTech.parent);
                    researchedTechs.splice(parentInsertIndex, 0, bonusTech.parent);
                    researchOrder.splice(parentInsertIndex, 0, Date.now() - 500);
                }
                
                // Now add the bonus tech
                researchedBonusTechs.push(bonusTechId);
                
                // Record action for undo
                recordAction('addBonusTech', {
                    bonusTechName: bonusTech.name,
                    previousBonusTechs: previousBonusTechs,
                    previousTechs: previousTechs,
                    previousOrder: previousOrder,
                    previousCompleted: previousCompleted
                });
            }
            
            updateTechStates(); // Update main tech states too since we may have added main techs
            updateBonusTechStates();
            updateOrderList();
            drawConnections(); // Redraw connections since main techs may have changed
            saveToLocalStorage(); // Save state after changes
        }

        function updateBonusTechStates() {
            // Filter bonus techs based on selected nation - same logic as initializeBonusTechs
            const availableBonusTechs = techData.bonusTechs.filter(bonusTech => {
                // Show general bonus techs (no nation property)
                if (!bonusTech.nation) return true;
                // Show nation-specific bonus techs only if nation is selected and matches
                return selectedNation && bonusTech.nation === selectedNation;
            });
            
            availableBonusTechs.forEach(bonusTech => {
                const node = document.getElementById(bonusTech.id);
                if (node) {
                    node.classList.remove('available', 'researched', 'completed', 'on-path');
                    
                    // Remove existing order badge
                    const existingBadge = node.querySelector('.tech-order-badge');
                    if (existingBadge) {
                        existingBadge.remove();
                    }
                    
                    if (researchedBonusTechs.includes(bonusTech.id)) {
                        // Check if completed or just on-path
                        if (completedTechs.includes(bonusTech.id)) {
                            node.classList.add('completed');
                        } else {
                            node.classList.add('on-path');
                        }
                        
                        // Add order badge - calculate position in overall research order
                        const allResearched = [...researchedTechs, ...researchedBonusTechs];
                        const overallIndex = allResearched.indexOf(bonusTech.id);
                        if (overallIndex > -1) {
                            const badge = document.createElement('div');
                            badge.className = 'tech-order-badge';
                            badge.textContent = overallIndex + 1;
                            node.appendChild(badge);
                        }
                    } else if (researchedTechs.includes(bonusTech.parent)) {
                        node.classList.add('available');
                    }
                }
            });
        }

        function showBonusTooltip(event, bonusTech) {
            const tooltip = document.getElementById('tooltip');
            const parentTech = techData.techs.find(t => t.id === bonusTech.parent);
            const parentName = parentTech ? parentTech.name : bonusTech.parent;
            
            tooltip.innerHTML = `
                <h3>${bonusTech.name}</h3>
                <p><strong>Cost:</strong> ${bonusTech.cost} Science</p>
                <p><strong>Requires:</strong> ${parentName}</p>
                <p><strong>Bonus:</strong> ${bonusTech.bonus}</p>
                <p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to add/remove • Right-click to mark completed</p>
            `;
            
            positionTooltip(event, tooltip);
        }

        function toggleResearch(techId) {
            const tech = techData.techs.find(t => t.id === techId);
            const index = researchedTechs.indexOf(techId);
            
            // Save state before changes for undo
            const previousTechs = researchedTechs.slice();
            const previousOrder = researchOrder.slice();
            const previousCompleted = completedTechs.slice();
            
            if (index > -1) {
                // Remove this tech and all techs that depend on it
                const techsToRemove = getTechsToRemove(techId);
                researchedTechs = researchedTechs.filter(id => !techsToRemove.includes(id));
                researchOrder = researchOrder.slice(0, researchedTechs.length);
                
                // Record action for undo
                recordAction('removeTech', {
                    techName: tech ? tech.name : techId,
                    removedTechs: techsToRemove,
                    previousTechs: previousTechs,
                    previousOrder: previousOrder,
                    previousCompleted: previousCompleted
                });
            } else {
                // Add this tech and all its prerequisites
                const prereqsToAdd = getAllPrerequisites(techId);
                const addedTechs = [];
                
                prereqsToAdd.forEach(prereqId => {
                    if (!researchedTechs.includes(prereqId)) {
                        researchedTechs.push(prereqId);
                        researchOrder.push(Date.now());
                        addedTechs.push(prereqId);
                    }
                });
                
                // Add the clicked tech itself if not already added
                if (!researchedTechs.includes(techId)) {
                    researchedTechs.push(techId);
                    researchOrder.push(Date.now());
                    addedTechs.push(techId);
                }
                
                // Record action for undo
                recordAction('addTech', {
                    techName: tech ? tech.name : techId,
                    addedTechs: addedTechs,
                    previousTechs: previousTechs,
                    previousOrder: previousOrder,
                    previousCompleted: previousCompleted
                });
            }
            updateTechStates();
            updateBonusTechStates(); // Update bonus techs when main techs change
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after changes
        }

        function getAllPrerequisites(techId) {
            const visited = new Set();
            const result = [];
            
            // Get starting techs for current nation
            const startingTechs = selectedNation && nationData.startingTechs[selectedNation] 
                ? new Set(nationData.startingTechs[selectedNation]) 
                : new Set();
            
            function addPrereqs(id) {
                if (visited.has(id)) return;
                visited.add(id);
                
                // Skip if this is a starting tech (already have it)
                if (startingTechs.has(id)) return;
                
                const tech = techData.techs.find(t => t.id === id);
                if (!tech) return;
                
                // First add all prerequisites of this tech
                tech.prereqs.forEach(prereqId => {
                    // Skip if this prerequisite is a starting tech (already have it)
                    if (!startingTechs.has(prereqId)) {
                        addPrereqs(prereqId);
                    }
                });
                
                // Then add this tech (ensuring prerequisites come first)
                if (!result.includes(id)) {
                    result.push(id);
                }
            }
            
            const tech = techData.techs.find(t => t.id === techId);
            if (tech) {
                tech.prereqs.forEach(prereqId => {
                    // Skip if this prerequisite is a starting tech (already have it)
                    if (!startingTechs.has(prereqId)) {
                        addPrereqs(prereqId);
                    }
                });
            }
            
            return result;
        }
        
        function calculateDeltaCost(techId) {
            // Calculate the additional cost needed to research this tech
            const tech = techData.techs.find(t => t.id === techId);
            if (!tech) return 0;
            
            // If already researched, delta is 0
            if (researchedTechs.includes(techId)) return 0;
            
            // Get all prerequisites needed
            const prereqsNeeded = getAllPrerequisites(techId);
            
            // Calculate total cost = cost of prereqs not yet researched + tech itself
            let totalCost = 0;
            
            // Add cost of prerequisites not yet researched
            prereqsNeeded.forEach(prereqId => {
                if (!researchedTechs.includes(prereqId)) {
                    const prereqTech = techData.techs.find(t => t.id === prereqId);
                    if (prereqTech) {
                        totalCost += prereqTech.cost;
                    }
                }
            });
            
            // Add cost of the tech itself
            totalCost += tech.cost;
            
            return totalCost;
        }
        
        function showPrerequisitePreview(techId) {
            // Clear any existing previews
            clearPrerequisitePreview();
            
            // Don't show preview for already researched techs
            if (researchedTechs.includes(techId)) return;
            
            // Add preview to the hovered tech itself
            const hoveredNode = document.getElementById(techId);
            if (hoveredNode) {
                hoveredNode.classList.add('prereq-preview');
            }
            
            // Get prerequisites that would be added
            const prereqsNeeded = getAllPrerequisites(techId);
            
            // Highlight prerequisites that aren't already researched
            prereqsNeeded.forEach(prereqId => {
                if (!researchedTechs.includes(prereqId)) {
                    const node = document.getElementById(prereqId);
                    if (node) {
                        node.classList.add('prereq-preview');
                    }
                }
            });
        }
        
        function clearPrerequisitePreview() {
            // Remove preview class from all nodes
            document.querySelectorAll('.tech-node.prereq-preview').forEach(node => {
                node.classList.remove('prereq-preview');
            });
        }
        
        function recordAction(type, data) {
            // Add action to undo history
            undoHistory.push({
                type: type,
                data: data,
                timestamp: Date.now()
            });
            
            // Clear redo history when new action is performed
            redoHistory = [];
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            // Update undo/redo button states
            updateUndoRedoButtons();
        }
        
        function undoLastAction() {
            if (undoHistory.length === 0) return;
            
            const action = undoHistory.pop();
            
            // Add to redo history
            redoHistory.push(action);
            if (redoHistory.length > MAX_REDO_HISTORY) {
                redoHistory.shift();
            }
            
            switch(action.type) {
                case 'addTech':
                    // Remove the added techs
                    researchedTechs = action.data.previousTechs.slice();
                    researchOrder = action.data.previousOrder.slice();
                    completedTechs = action.data.previousCompleted.slice();
                    break;
                    
                case 'removeTech':
                    // Re-add the removed techs
                    researchedTechs = action.data.previousTechs.slice();
                    researchOrder = action.data.previousOrder.slice();
                    completedTechs = action.data.previousCompleted.slice();
                    break;
                    
                case 'addBonusTech':
                    // Remove the added bonus tech and any main techs that were added
                    researchedBonusTechs = action.data.previousBonusTechs.slice();
                    researchedTechs = action.data.previousTechs.slice();
                    researchOrder = action.data.previousOrder.slice();
                    completedTechs = action.data.previousCompleted.slice();
                    break;
                    
                case 'removeBonusTech':
                    // Re-add the removed bonus tech
                    researchedBonusTechs = action.data.previousBonusTechs.slice();
                    break;
                    
                case 'toggleCompletion':
                    // Restore previous completion state
                    completedTechs = action.data.previousCompleted.slice();
                    break;
                    
                case 'clearAll':
                    // Restore everything that was cleared
                    researchedTechs = action.data.previousTechs.slice();
                    researchOrder = action.data.previousOrder.slice();
                    researchedBonusTechs = action.data.previousBonusTechs.slice();
                    completedTechs = action.data.previousCompleted.slice();
                    break;
            }
            
            // Update displays
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage();
            updateUndoRedoButtons();
        }
        
        function redoLastAction() {
            if (redoHistory.length === 0) return;
            
            const action = redoHistory.pop();
            
            // Add back to undo history
            undoHistory.push(action);
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            // Re-apply the action
            switch(action.type) {
                case 'addTech':
                    // Re-add the techs
                    researchedTechs = action.data.previousTechs.slice();
                    researchOrder = action.data.previousOrder.slice();
                    completedTechs = action.data.previousCompleted.slice();
                    
                    // Now add the techs that were originally added
                    action.data.addedTechs.forEach(techId => {
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    });
                    break;
                    
                case 'removeTech':
                    // Re-remove the techs
                    researchedTechs = action.data.previousTechs.slice();
                    researchOrder = action.data.previousOrder.slice();
                    completedTechs = action.data.previousCompleted.slice();
                    
                    // Now remove the techs that were originally removed
                    researchedTechs = researchedTechs.filter(id => !action.data.removedTechs.includes(id));
                    researchOrder = researchOrder.slice(0, researchedTechs.length);
                    break;
                    
                case 'addBonusTech':
                    // Re-add the bonus tech
                    researchedBonusTechs = action.data.previousBonusTechs.slice();
                    researchedTechs = action.data.previousTechs.slice();
                    researchOrder = action.data.previousOrder.slice();
                    completedTechs = action.data.previousCompleted.slice();
                    
                    // Re-apply the addition
                    const bonusTech = techData.bonusTechs.find(t => t.name === action.data.bonusTechName);
                    if (bonusTech && !researchedBonusTechs.includes(bonusTech.id)) {
                        researchedBonusTechs.push(bonusTech.id);
                    }
                    break;
                    
                case 'removeBonusTech':
                    // Re-remove the bonus tech
                    researchedBonusTechs = action.data.previousBonusTechs.slice();
                    const bonusToRemove = techData.bonusTechs.find(t => t.name === action.data.bonusTechName);
                    if (bonusToRemove) {
                        const index = researchedBonusTechs.indexOf(bonusToRemove.id);
                        if (index > -1) {
                            researchedBonusTechs.splice(index, 1);
                        }
                    }
                    break;
                    
                case 'toggleCompletion':
                    // Re-toggle completion
                    completedTechs = action.data.previousCompleted.slice();
                    const techToToggle = action.data.techName;
                    const tech = techData.techs.find(t => t.name === techToToggle) || 
                                 techData.bonusTechs.find(t => t.name === techToToggle);
                    if (tech) {
                        if (action.data.wasCompleted) {
                            // Was completed, so remove from completed
                            const idx = completedTechs.indexOf(tech.id);
                            if (idx > -1) completedTechs.splice(idx, 1);
                        } else {
                            // Was not completed, so add to completed
                            if (!completedTechs.includes(tech.id)) {
                                completedTechs.push(tech.id);
                            }
                        }
                    }
                    break;
                    
                case 'clearAll':
                    // Re-clear everything
                    researchedTechs = [];
                    researchOrder = [];
                    researchedBonusTechs = [];
                    completedTechs = [];
                    break;
            }
            
            // Update displays
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage();
            updateUndoRedoButtons();
        }
        
        function updateUndoRedoButtons() {
            const undoButtons = document.querySelectorAll('.undo-button');
            const redoButtons = document.querySelectorAll('.redo-button');
            
            // Update undo buttons
            undoButtons.forEach(undoButton => {
                if (undoHistory.length === 0) {
                    undoButton.classList.add('disabled');
                    undoButton.textContent = 'Undo';
                } else {
                    undoButton.classList.remove('disabled');
                    const lastAction = undoHistory[undoHistory.length - 1];
                    
                    // Create descriptive text for the last action
                    let actionText = '← Undo: ';
                    switch(lastAction.type) {
                        case 'addTech':
                            actionText += `Added ${lastAction.data.techName}`;
                            break;
                        case 'removeTech':
                            actionText += `Removed ${lastAction.data.techName}`;
                            break;
                        case 'addBonusTech':
                            actionText += `Added ${lastAction.data.bonusTechName}`;
                            break;
                        case 'removeBonusTech':
                            actionText += `Removed ${lastAction.data.bonusTechName}`;
                            break;
                        case 'toggleCompletion':
                            actionText += lastAction.data.wasCompleted ? 'Unmarked' : 'Marked';
                            actionText += ` ${lastAction.data.techName}`;
                            break;
                        case 'clearAll':
                            actionText += `Cleared ${lastAction.data.clearedCount} tech${lastAction.data.clearedCount !== 1 ? 's' : ''}`;
                            break;
                        default:
                            actionText += 'Last action';
                    }
                    
                    undoButton.textContent = 'Undo';
                }
            });
            
            // Update redo buttons
            redoButtons.forEach(redoButton => {
                if (redoHistory.length === 0) {
                    redoButton.style.display = 'none';
                } else {
                    redoButton.style.display = '';
                    redoButton.classList.remove('disabled');
                }
            });
        }
        
        function findInsertionIndex(techId) {
            // Find the correct position to insert a tech to maintain tech tree order
            // Insert after all prerequisites but before any techs that depend on this one
            
            const tech = techData.techs.find(t => t.id === techId);
            if (!tech) return researchedTechs.length;
            
            // Find latest prerequisite position
            let latestPrereqIndex = -1;
            tech.prereqs.forEach(prereqId => {
                const prereqIndex = researchedTechs.indexOf(prereqId);
                if (prereqIndex > latestPrereqIndex) {
                    latestPrereqIndex = prereqIndex;
                }
            });
            
            // Insert after the latest prerequisite
            return latestPrereqIndex + 1;
        }

        function getTechsToRemove(techId) {
            const toRemove = new Set([techId]);
            let changed = true;
            
            // Get starting techs for current nation - these should never be removed
            const startingTechs = selectedNation && nationData.startingTechs[selectedNation] 
                ? new Set(nationData.startingTechs[selectedNation]) 
                : new Set();
            
            // Keep finding techs that depend on techs we're removing
            while (changed) {
                changed = false;
                researchedTechs.forEach(id => {
                    if (!toRemove.has(id) && !startingTechs.has(id)) { // Never remove starting techs
                        const tech = techData.techs.find(t => t.id === id);
                        if (tech && tech.prereqs.some(prereq => toRemove.has(prereq))) {
                            // Check if this tech has alternative paths through starting techs
                            const hasAlternativePath = tech.prereqs.some(prereq => {
                                // If this prerequisite is being removed, check if we can reach this tech through starting techs
                                if (toRemove.has(prereq)) {
                                    return startingTechs.size > 0 && Array.from(startingTechs).some(startingTech => {
                                        return canReachTech(startingTech, id, new Set());
                                    });
                                }
                                return true; // This prerequisite is not being removed
                            });
                            
                            // Only remove if no alternative path exists
                            if (!hasAlternativePath) {
                                toRemove.add(id);
                                changed = true;
                            }
                        }
                    }
                });
            }
            
            return Array.from(toRemove);
        }

        function updateTechStates() {
            techData.techs.forEach(tech => {
                const node = document.getElementById(tech.id);
                node.classList.remove('researched', 'available', 'completed', 'on-path');
                
                // Remove order badge
                const existingBadge = node.querySelector('.tech-order-badge');
                if (existingBadge) {
                    existingBadge.remove();
                }
                
                // Remove delta cost indicator
                const existingDeltaCost = node.querySelector('.tech-delta-cost');
                if (existingDeltaCost) {
                    existingDeltaCost.remove();
                }
                
                const techIndex = researchedTechs.indexOf(tech.id);
                if (techIndex > -1) {
                    // Check if this tech is completed or just on-path
                    // Starting techs are always completed
                    const isStartingTech = selectedNation && 
                        nationData.startingTechs[selectedNation] && 
                        nationData.startingTechs[selectedNation].includes(tech.id);
                    
                    if (isStartingTech || completedTechs.includes(tech.id)) {
                        node.classList.add('completed');
                    } else {
                        node.classList.add('on-path');
                    }
                    
                    // Add order badge
                    const badge = document.createElement('div');
                    badge.className = 'tech-order-badge';
                    badge.textContent = techIndex + 1;
                    node.appendChild(badge);
                } else if (isAvailable(tech)) {
                    node.classList.add('available');
                }
                
                // Add delta cost indicator for all unresearched techs
                if (techIndex === -1) {
                    const deltaCost = calculateDeltaCost(tech.id);
                    if (deltaCost > 0) {
                        const deltaCostElement = document.createElement('div');
                        deltaCostElement.className = 'tech-delta-cost';
                        deltaCostElement.textContent = deltaCost;
                        node.appendChild(deltaCostElement);
                    }
                }
            });
        }
        
        function toggleTechCompletion(techId) {
            // Don't allow toggling starting techs
            if (selectedNation && nationData.startingTechs[selectedNation] && 
                nationData.startingTechs[selectedNation].includes(techId)) {
                return;
            }
            
            const index = completedTechs.indexOf(techId);
            if (index > -1) {
                // Remove from completed
                completedTechs.splice(index, 1);
            } else {
                // Add to completed
                completedTechs.push(techId);
            }
            
            // Update displays
            updateTechStates();
            updateOrderList();
            saveToLocalStorage();
        }
        
        function quickToggleCompletion(techId) {
            // Right-click: directly toggle completed state (add to researched if needed)
            if (!researchedTechs.includes(techId)) {
                // Add prerequisites and the tech itself
                const prereqsToAdd = getAllPrerequisites(techId);
                prereqsToAdd.forEach(prereqId => {
                    if (!researchedTechs.includes(prereqId)) {
                        researchedTechs.push(prereqId);
                        researchOrder.push(Date.now());
                        completedTechs.push(prereqId); // Mark prereqs as completed too
                    }
                });
                
                // Add and complete the tech itself
                researchedTechs.push(techId);
                researchOrder.push(Date.now());
                completedTechs.push(techId);
            } else {
                // Toggle completion state
                toggleTechCompletion(techId);
            }
            
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage();
        }
        
        function toggleBonusTechCompletion(bonusTechId) {
            const index = completedTechs.indexOf(bonusTechId);
            if (index > -1) {
                // Remove from completed
                completedTechs.splice(index, 1);
            } else {
                // Add to completed
                completedTechs.push(bonusTechId);
            }
            
            // Update displays
            updateBonusTechStates();
            updateOrderList();
            saveToLocalStorage();
        }
        
        function quickToggleBonusCompletion(bonusTechId) {
            const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
            if (!bonusTech) return;
            
            // Ensure parent tech is researched first
            if (!researchedTechs.includes(bonusTech.parent)) {
                quickToggleCompletion(bonusTech.parent);
            }
            
            // Toggle bonus tech
            if (!researchedBonusTechs.includes(bonusTechId)) {
                researchedBonusTechs.push(bonusTechId);
                completedTechs.push(bonusTechId);
            } else {
                const index = completedTechs.indexOf(bonusTechId);
                if (index > -1) {
                    completedTechs.splice(index, 1);
                } else {
                    completedTechs.push(bonusTechId);
                }
            }
            
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage();
        }

        function isAvailable(tech) {
            return tech.prereqs.every(prereq => researchedTechs.includes(prereq));
        }

        function updateOrderList() {
            const list = document.getElementById('techOrderList');
            const totalCostElement = document.getElementById('totalCost');
            const totalLawsElement = document.getElementById('totalLaws');
            const totalCostMobileElement = document.getElementById('totalCostMobile');
            const totalLawsMobileElement = document.getElementById('totalLawsMobile');
            list.innerHTML = '';
            
            let totalCost = 0;
            let totalLaws = 0;
            let itemIndex = 1;
            
            // Create unified ordering: combine main techs with their associated bonus techs
            const unifiedOrder = [];
            
            // Add main techs in order
            researchedTechs.forEach((techId) => {
                unifiedOrder.push({ type: 'main', id: techId });
                
                // Add any bonus techs that belong to this main tech
                researchedBonusTechs.forEach((bonusTechId) => {
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    if (bonusTech && bonusTech.parent === techId) {
                        unifiedOrder.push({ type: 'bonus', id: bonusTechId });
                    }
                });
            });
            
            // Process the unified order
            unifiedOrder.forEach((item) => {
                if (item.type === 'main') {
                    const techId = item.id;
                const tech = techData.techs.find(t => t.id === techId);
                const isStartingTech = selectedNation && 
                    nationData.startingTechs[selectedNation] && 
                    nationData.startingTechs[selectedNation].includes(techId);
                
                if (!isStartingTech) {
                    totalCost += tech.cost;
                }
                
                // Count laws from this tech
                const hasLaws = tech.unlocks && tech.unlocks.laws && tech.unlocks.laws.length > 0;
                if (hasLaws) {
                    totalLaws += tech.unlocks.laws.length;
                }
                
                const listItem = document.createElement('div');
                // Starting techs are always completed
                const isCompleted = isStartingTech || completedTechs.includes(techId);
                listItem.className = isCompleted ? 'tech-order-item completed' : 'tech-order-item';
                listItem.setAttribute('data-tech-id', techId);
                listItem.style.cursor = isStartingTech ? 'default' : 'pointer';
                
                // Add law icon at the front if this tech unlocks laws
                const lawIcon = hasLaws ? '⚖️ ' : '';
                // Add checkmark if completed
                const checkmark = isCompleted ? '✓ ' : '';
                
                if (isStartingTech) {
                    listItem.innerHTML = `
                        <span class="tech-order-number">${checkmark}${itemIndex}.</span>
                        <span class="tech-order-name">${lawIcon}${tech.name}</span>
                        <span class="tech-order-cost"><span style="text-decoration: line-through; color: #888;">${tech.cost}</span> <strong style="color: #5a8a3a;">FREE</strong></span>
                    `;
                } else {
                    listItem.innerHTML = `
                        <span class="tech-order-number">${checkmark}${itemIndex}.</span>
                        <span class="tech-order-name">${lawIcon}${tech.name}</span>
                        <span class="tech-order-cost">${tech.cost}</span>
                    `;
                }
                
                // Add click event to toggle completion
                listItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleTechCompletion(techId);
                });
                
                // Add hover events for tooltip
                listItem.addEventListener('mouseenter', (e) => {
                    console.log('Tech tooltip triggered for:', tech.name);
                    showResearchOrderTooltip(e, tech, isStartingTech, isCompleted);
                });
                listItem.addEventListener('mouseleave', hideTooltip);
                
                list.appendChild(listItem);
                itemIndex++;
                } else if (item.type === 'bonus') {
                    const bonusTechId = item.id;
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    totalCost += bonusTech.cost;
                    
                    const listItem = document.createElement('div');
                    const isCompleted = completedTechs.includes(bonusTechId);
                    listItem.className = isCompleted ? 'tech-order-item completed' : 'tech-order-item';
                    listItem.setAttribute('data-bonus-tech-id', bonusTechId);
                    if (!isCompleted) {
                        listItem.style.backgroundColor = 'rgba(180, 160, 55, 0.2)'; // Highlight bonus techs only if not completed
                    }
                    listItem.style.cursor = 'pointer';
                    
                    // Add checkmark if completed
                    const checkmark = isCompleted ? '✓ ' : '';
                    
                    listItem.innerHTML = `
                        <span class="tech-order-number">${checkmark}${itemIndex}.</span>
                        <span class="tech-order-name">💎 ${bonusTech.name}</span>
                        <span class="tech-order-cost">${bonusTech.cost}</span>
                    `;
                    
                    // Add click event to toggle completion
                    listItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleBonusTechCompletion(bonusTechId);
                    });
                    
                    // Add hover events for bonus tech tooltip
                    listItem.addEventListener('mouseenter', (e) => {
                        console.log('Bonus tooltip triggered for:', bonusTech.name);
                        showResearchOrderBonusTooltip(e, bonusTech, isCompleted);
                    });
                    listItem.addEventListener('mouseleave', hideTooltip);
                    
                    list.appendChild(listItem);
                    itemIndex++;
                }
            });
            
            totalCostElement.textContent = `${totalCost} 🧪`;
            totalLawsElement.textContent = `Laws: ${totalLaws}`;
            if (totalCostMobileElement) totalCostMobileElement.textContent = `${totalCost} 🧪`;
            if (totalLawsMobileElement) totalLawsMobileElement.textContent = `Laws: ${totalLaws}`;
            
            // Update clear button state for both desktop and mobile
            const clearButtons = document.querySelectorAll('.clear-button');
            clearButtons.forEach(button => {
                if (researchedTechs.length === 0 && researchedBonusTechs.length === 0) {
                    button.classList.add('disabled');
                } else {
                    button.classList.remove('disabled');
                }
            });
        }

        let connections = []; // Store line objects for cleanup
        
        function drawConnections() {
            // Remove existing connections
            connections.forEach(line => line.remove());
            connections = [];
            
            // Draw connections using Leader Line (only for main techs, not bonus techs)
            techData.techs.forEach(tech => {
                if (tech.prereqs.length > 0) {
                    const toNode = document.getElementById(tech.id);
                    if (!toNode) return;
                    
                    tech.prereqs.forEach(prereqId => {
                        const fromNode = document.getElementById(prereqId);
                        if (fromNode) {
                            // Determine line color based on research status
                            let lineColor = '#4a3426'; // default
                            if (researchedTechs.includes(prereqId) && researchedTechs.includes(tech.id)) {
                                lineColor = '#5a8a3a'; // both researched
                            } else if (researchedTechs.includes(prereqId) && isAvailable(tech)) {
                                lineColor = '#b4a037'; // prereq researched, target available
                            }
                            
                            // Create line using Leader Line
                            const line = new LeaderLine(fromNode, toNode, {
                                color: lineColor,
                                size: 2,
                                path: 'straight',
                                startSocket: 'right',
                                endSocket: 'left',
                                startSocketGravity: 100,
                                endSocketGravity: 100
                            });
                            
                            connections.push(line);
                        }
                    });
                }
            });
        }

        function showResearchOrderTooltip(event, tech, isStartingTech, isCompleted) {
            const tooltip = document.getElementById('tooltip');
            const prereqNames = tech.prereqs.map(id => {
                const prereqTech = techData.techs.find(t => t.id === id);
                return prereqTech ? prereqTech.name : id;
            }).join(', ');
            
            let actionText = '';
            if (isStartingTech) {
                actionText = '<p style="margin-top: 8px; font-style: italic; color: #a09080;">Starting tech (always completed)</p>';
            } else if (isCompleted) {
                actionText = '<p style="margin-top: 8px; font-style: italic; color: #a09080;">✓ Completed • Click to mark as not completed</p>';
            } else {
                actionText = '<p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to mark as completed</p>';
            }
            
            tooltip.innerHTML = `
                <h3>${tech.name}</h3>
                <p><strong>Cost:</strong> ${tech.cost} Science</p>
                ${tech.prereqs.length > 0 ? `<p><strong>Prerequisites:</strong> ${prereqNames}</p>` : ''}
                ${actionText}
            `;
            
            positionTooltip(event, tooltip);
        }
        
        function showResearchOrderBonusTooltip(event, bonusTech, isCompleted) {
            const tooltip = document.getElementById('tooltip');
            const parentTech = techData.techs.find(t => t.id === bonusTech.parent);
            const parentName = parentTech ? parentTech.name : bonusTech.parent;
            
            let actionText = isCompleted 
                ? '<p style="margin-top: 8px; font-style: italic; color: #a09080;">✓ Completed • Click to mark as not completed</p>'
                : '<p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to mark as completed</p>';
            
            tooltip.innerHTML = `
                <h3>${bonusTech.name}</h3>
                <p><strong>Cost:</strong> ${bonusTech.cost} Science</p>
                <p><strong>Requires:</strong> ${parentName}</p>
                <p><strong>Bonus:</strong> ${bonusTech.bonus}</p>
                ${actionText}
            `;
            
            positionTooltip(event, tooltip);
        }
        
        function positionTooltip(event, tooltip) {
            // Position tooltip accounting for scroll and viewport bounds
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // Check if tooltip would go off screen and adjust
            const viewportWidth = window.innerWidth;
            
            // If too far right, position to left of element
            if (left + 300 > viewportWidth + scrollLeft) {
                left = rect.left + scrollLeft - 310;
            }
            
            // If too high (near top), position below element
            if (rect.top < 150) {
                top = rect.bottom + scrollTop + 10;
            }
            
            // Ensure tooltip doesn't go above the viewport
            if (top < scrollTop + 10) {
                top = scrollTop + 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.add('show');
        }
        
        function showTooltip(event, tech) {
            const tooltip = document.getElementById('tooltip');
            const prereqNames = tech.prereqs.map(id => {
                const prereqTech = techData.techs.find(t => t.id === id);
                return prereqTech ? prereqTech.name : id;
            }).join(', ');
            
            let unlocksList = '';
            const hasUnlocks = tech.unlocks.units?.length > 0 || tech.unlocks.projects?.length > 0 || 
                              tech.unlocks.improvements?.length > 0 || tech.unlocks.laws?.length > 0;
            const hasBonusTechs = techData.bonusTechs.some(bonus => {
                if (bonus.parent !== tech.id) return false;
                // Only count nation-specific bonus techs if that nation is selected
                if (bonus.nation && bonus.nation !== selectedNation) return false;
                return true;
            });
            
            if (hasUnlocks || hasBonusTechs) {
                unlocksList = '<div class="unlocks-list"><h4>Unlocks:</h4><ul>';
                if (tech.unlocks.units?.length > 0) {
                    tech.unlocks.units.forEach(unit => {
                        unlocksList += `<li>⚔️ ${unit}</li>`;
                    });
                }
                if (tech.unlocks.improvements?.length > 0) {
                    tech.unlocks.improvements.forEach(improvement => {
                        // Only show Kushite Pyramids if Kush is selected
                        if (improvement === "Kushite Pyramids" && selectedNation !== "NATION_KUSH") {
                            return;
                        }
                        unlocksList += `<li>🏗️ ${improvement}</li>`;
                    });
                }
                if (tech.unlocks.laws?.length > 0) {
                    tech.unlocks.laws.forEach(law => {
                        unlocksList += `<li>⚖️ ${law}</li>`;
                    });
                }
                if (tech.unlocks.projects?.length > 0) {
                    tech.unlocks.projects.forEach(project => {
                        unlocksList += `<li>🏛️ ${project}</li>`;
                    });
                }
                if (hasBonusTechs) {
                    const bonusTechs = techData.bonusTechs.filter(bonus => {
                        if (bonus.parent !== tech.id) return false;
                        // Only show nation-specific bonus techs if that nation is selected
                        if (bonus.nation && bonus.nation !== selectedNation) return false;
                        return true;
                    });
                    bonusTechs.forEach(bonusTech => {
                        unlocksList += `<li>💎 ${bonusTech.name}</li>`;
                    });
                }
                unlocksList += '</ul></div>';
            }
            
            tooltip.innerHTML = `
                <h3>${tech.name}</h3>
                <p><strong>Cost:</strong> ${tech.cost} Science</p>
                ${tech.prereqs.length > 0 ? `<p><strong>Prerequisites:</strong> ${prereqNames}</p>` : ''}
                ${unlocksList}
                <p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to add/remove • Right-click to mark completed</p>
            `;
            
            positionTooltip(event, tooltip);
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }

        function showBonusTooltip(event, bonusTech) {
            const tooltip = document.getElementById('tooltip');
            
            // Find parent tech
            const parentTech = techData.techs.find(t => t.id === bonusTech.parent);
            const parentName = parentTech ? parentTech.name : bonusTech.parent;
            
            // Determine the appropriate emoji based on bonus content
            let bonusEmoji = '💎';
            if (bonusTech.bonus.includes('Stone') || bonusTech.bonus.includes('Iron') || bonusTech.bonus.includes('Food')) {
                bonusEmoji = '📦'; // Resources
            } else if (bonusTech.bonus.includes('Worker') || bonusTech.bonus.includes('Science')) {
                bonusEmoji = '🔬'; // Science/Workers
            } else if (bonusTech.bonus.includes('Courtier') || bonusTech.bonus.includes('General') || 
                      bonusTech.bonus.includes('Governor') || bonusTech.bonus.includes('Spymaster')) {
                bonusEmoji = '👤'; // Courtiers
            } else if (bonusTech.bonus.includes('+1') || bonusTech.bonus.includes('+2')) {
                bonusEmoji = '⚔️'; // Units
            }
            
            tooltip.innerHTML = `
                <h3>${bonusTech.name}</h3>
                <p><strong>Cost:</strong> ${bonusTech.cost} 🧪</p>
                <p><strong>Parent Tech:</strong> ${parentName}</p>
                <div class="unlocks-list">
                    <h4>Bonus:</h4>
                    <ul><li>${bonusEmoji} ${bonusTech.bonus}</li></ul>
                </div>
            `;
            
            // Position tooltip accounting for scroll and viewport
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Try to position to the right of the item, but adjust if it would go off-screen
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // If tooltip would go off the right edge, position it to the left
            if (left + 300 > window.innerWidth) { // Assuming tooltip is ~300px wide
                left = rect.left + scrollLeft - 310;
            }
            
            // If tooltip would go off the bottom, adjust upward
            if (top + 200 > window.innerHeight + scrollTop) { // Assuming tooltip is ~200px tall
                top = rect.bottom + scrollTop - 200;
            }
            
            tooltip.style.left = Math.max(10, left) + 'px'; // Don't go off left edge
            tooltip.style.top = Math.max(10, top) + 'px'; // Don't go off top edge
            tooltip.classList.add('show');
        }

        function animateConnectionsDuringSidebarToggle() {
            // Redraw connections smoothly during the animation
            const animationDuration = 300; // Match CSS transition duration
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                drawConnections();
                
                if (elapsed < animationDuration) {
                    requestAnimationFrame(animate);
                } else {
                    // Final redraw to ensure perfect positioning
                    drawConnections();
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContainer = document.querySelector('.main-container');
            const toggleIcon = document.getElementById('toggleIcon');
            
            // Check if we're on mobile
            const isMobile = window.innerWidth <= 900;
            
            if (isMobile) {
                // Mobile behavior - slide up/down
                if (sidebar.classList.contains('mobile-visible')) {
                    sidebar.classList.remove('mobile-visible');
                } else {
                    sidebar.classList.add('mobile-visible');
                }
            } else {
                // Desktop behavior - slide in/out from right
                if (sidebar.classList.contains('collapsed')) {
                    sidebar.classList.remove('collapsed');
                    mainContainer.classList.remove('sidebar-collapsed');
                    toggleIcon.textContent = '▶';
                } else {
                    sidebar.classList.add('collapsed');
                    mainContainer.classList.add('sidebar-collapsed');
                    toggleIcon.textContent = '◀';
                }
                // Animate connections during sidebar toggle
                animateConnectionsDuringSidebarToggle();
            }
        }

        function shareBuild() {
            if (researchedTechs.length === 0 && !selectedNation) {
                alert('No technologies researched or nation selected to share!');
                return;
            }
            
            const urlParts = [];
            
            // Add nation if selected (using numeric index)
            if (selectedNation) {
                const nationIndex = nationLookup.findIndex(n => n === selectedNation);
                if (nationIndex !== -1) {
                    urlParts.push(`n=${nationIndex}`);
                }
            }
            
            // Add techs if any are researched
            if (researchedTechs.length > 0) {
                const techNumbers = researchedTechs.map(techId => {
                    return techData.techs.findIndex(t => t.id === techId);
                }).filter(index => index !== -1);
                urlParts.push(`t=${techNumbers.join(',')}`);
            }
            
            // Add bonus techs if any are researched
            if (researchedBonusTechs.length > 0) {
                const bonusNumbers = researchedBonusTechs.map(bonusTechId => {
                    return techData.bonusTechs.findIndex(t => t.id === bonusTechId);
                }).filter(index => index !== -1);
                urlParts.push(`b=${bonusNumbers.join(',')}`);
            }
            
            const url = urlParts.length > 0 
                ? `https://alcaras.github.io/owtt/?${urlParts.join('&')}`
                : 'https://alcaras.github.io/owtt/';
            
            // Copy to clipboard and show feedback
            const shareButton = document.querySelector('.share-button');
            const originalText = shareButton.textContent;
            
            navigator.clipboard.writeText(url).then(() => {
                // Show "Copied!" feedback
                shareButton.textContent = 'Copied!';
                shareButton.style.background = 'linear-gradient(135deg, #4a8a4a, #6ab36a)';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    shareButton.textContent = originalText;
                    shareButton.style.background = 'linear-gradient(135deg, #8b6914, #b4a037)';
                }, 2000);
            }).catch(() => {
                // Fallback if clipboard API fails
                shareButton.textContent = 'Copy Failed';
                setTimeout(() => {
                    shareButton.textContent = originalText;
                }, 2000);
            });
        }

        function loadFromUrl() {
            const params = new URLSearchParams(window.location.search);
            
            // Load nation first (new format: n=index, old format: nation=NAME for backward compatibility)
            let nationParam = params.get('n');
            if (nationParam !== null) {
                const nationIndex = parseInt(nationParam);
                if (nationIndex >= 0 && nationIndex < nationLookup.length) {
                    selectedNation = nationLookup[nationIndex];
                }
            } else {
                // Backward compatibility with old format
                nationParam = params.get('nation');
                if (nationParam) {
                    selectedNation = nationParam;
                }
            }
            
            if (selectedNation) {
                const select = document.getElementById('nationSelect');
                select.value = selectedNation;
                
                // Add starting techs
                if (nationData.startingTechs[selectedNation]) {
                    const startingTechs = nationData.startingTechs[selectedNation];
                    startingTechs.forEach(techId => {
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    });
                }
            }
            
            // Load main techs (new format: t=1,2,3, old format: techs=1,2,3 for backward compatibility)
            let techsParam = params.get('t') || params.get('techs');
            if (techsParam) {
                const techNumbers = techsParam.split(',').map(n => parseInt(n)).filter(n => !isNaN(n));
                
                // Convert numbers back to tech IDs and validate
                techNumbers.forEach(techIndex => {
                    if (techIndex >= 0 && techIndex < techData.techs.length) {
                        const techId = techData.techs[techIndex].id;
                        const tech = techData.techs[techIndex];
                        
                        // Add prerequisites first
                        const prereqsToAdd = getAllPrerequisites(techId);
                        prereqsToAdd.forEach(prereqId => {
                            if (!researchedTechs.includes(prereqId)) {
                                researchedTechs.push(prereqId);
                                researchOrder.push(Date.now());
                            }
                        });
                        
                        // Add the tech itself
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    }
                });
            }
            
            // Load bonus techs (new format: b=1,2,3, old format: bonus=1,2,3 for backward compatibility)
            let bonusParam = params.get('b') || params.get('bonus');
            if (bonusParam) {
                const bonusNumbers = bonusParam.split(',').map(n => parseInt(n)).filter(n => !isNaN(n));
                
                bonusNumbers.forEach(bonusIndex => {
                    if (bonusIndex >= 0 && bonusIndex < techData.bonusTechs.length) {
                        const bonusTechId = techData.bonusTechs[bonusIndex].id;
                        if (!researchedBonusTechs.includes(bonusTechId)) {
                            researchedBonusTechs.push(bonusTechId);
                        }
                    }
                });
            }
            
            // Update displays
            initializeBonusTechs();
            updateOrderList();
        }

        function clearBuild() {
            // Check if any clear button is disabled
            const clearButtons = document.querySelectorAll('.clear-button');
            const anyDisabled = Array.from(clearButtons).some(btn => btn.classList.contains('disabled'));
            if (anyDisabled) {
                return; // Don't clear if disabled
            }
            
            // Save state before clearing for undo
            const previousTechs = researchedTechs.slice();
            const previousOrder = researchOrder.slice();
            const previousBonusTechs = researchedBonusTechs.slice();
            const previousCompleted = completedTechs.slice();
            
            // Only record if there was something to clear
            if (previousTechs.length > 0 || previousBonusTechs.length > 0) {
                recordAction('clearAll', {
                    previousTechs: previousTechs,
                    previousOrder: previousOrder,
                    previousBonusTechs: previousBonusTechs,
                    previousCompleted: previousCompleted,
                    clearedCount: previousTechs.length + previousBonusTechs.length
                });
            }
            
            // Preserve the selected nation
            const currentNation = selectedNation;
            
            researchedTechs = [];
            researchOrder = [];
            researchedBonusTechs = [];
            completedTechs = [];
            redoHistory = []; // Clear redo history too
            
            // If a nation is selected, keep it selected and add its starting techs back
            if (currentNation) {
                selectedNation = currentNation;
                
                // Add starting techs for the selected nation
                if (nationData.startingTechs[currentNation]) {
                    const startingTechs = nationData.startingTechs[currentNation];
                    startingTechs.forEach(techId => {
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    });
                }
                
                // Keep nation selector value
                const select = document.getElementById('nationSelect');
                select.value = currentNation;
            } else {
                // Only reset nation if none was selected
                selectedNation = '';
                const select = document.getElementById('nationSelect');
                select.value = '';
            }
            
            initializeBonusTechs();
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after clearing
            updateUndoRedoButtons(); // Update undo/redo button states
            
            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        // Helper function to check if a tech is a dependency for other researched techs
        function isTechDependency(techId, excludeTechs = []) {
            return researchedTechs.some(researchedId => {
                // Skip if this is one of the techs we're excluding from the check
                if (excludeTechs.includes(researchedId)) {
                    return false;
                }
                
                // Get all prerequisites for this researched tech (includes indirect dependencies)
                const allPrereqs = getAllPrerequisites(researchedId);
                
                // Check if techId is in the prerequisite chain
                return allPrereqs.includes(techId);
            });
        }
        
        function selectNation() {
            const select = document.getElementById('nationSelect');
            const previousNation = selectedNation;
            selectedNation = select.value;
            
            // Handle previous nation's techs and bonus cards
            if (previousNation && nationData.startingTechs[previousNation]) {
                const oldStartingTechs = nationData.startingTechs[previousNation];
                const newStartingTechs = selectedNation && nationData.startingTechs[selectedNation] 
                    ? nationData.startingTechs[selectedNation] : [];
                
                // Remove nation-specific bonus cards from the previous nation
                researchedBonusTechs = researchedBonusTechs.filter(bonusTechId => {
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    // Remove if it's nation-specific to the old nation
                    return !bonusTech || !bonusTech.nation || bonusTech.nation !== previousNation;
                });
                
                // Process each old starting tech
                const techsToRemove = [];
                oldStartingTechs.forEach(techId => {
                    // Keep if it's also a starting tech for the new nation
                    if (newStartingTechs.includes(techId)) {
                        return; // Keep it as a starting tech
                    }
                    
                    // Check if this tech is a dependency for other researched techs
                    // (excluding other old starting techs from the dependency check)
                    if (isTechDependency(techId, oldStartingTechs)) {
                        // Convert to regular tech (keep in list but not as starting)
                        return;
                    }
                    
                    // Otherwise, mark for removal
                    techsToRemove.push(techId);
                });
                
                // Remove techs that aren't dependencies
                researchedTechs = researchedTechs.filter(techId => !techsToRemove.includes(techId));
                researchOrder = researchOrder.slice(0, researchedTechs.length);
                completedTechs = completedTechs.filter(techId => !techsToRemove.includes(techId));
                
                // Also remove bonus techs whose parent was removed
                researchedBonusTechs = researchedBonusTechs.filter(bonusTechId => {
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    return bonusTech && !techsToRemove.includes(bonusTech.parent);
                });
            }
            
            // Add new nation's starting techs at the beginning if a nation is selected
            if (selectedNation && nationData.startingTechs[selectedNation]) {
                const startingTechs = nationData.startingTechs[selectedNation];
                
                // Add starting techs at the beginning of the list
                const newResearchedTechs = [];
                const newResearchOrder = [];
                
                startingTechs.forEach(techId => {
                    if (!researchedTechs.includes(techId)) {
                        newResearchedTechs.push(techId);
                        newResearchOrder.push(Date.now() - 10000); // Earlier timestamp
                    }
                });
                
                // Combine with existing techs
                researchedTechs = [...newResearchedTechs, ...researchedTechs];
                researchOrder = [...newResearchOrder, ...researchOrder];
            }
            
            // Update the bonus tech display to show/hide nation-specific bonuses
            initializeBonusTechs();
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after nation change
        }

        // Simulation functions
        function openSimulationPanel() {
            if (researchedTechs.length === 0) {
                alert('Please select some technologies to research first!');
                return;
            }
            
            document.getElementById('simulationOverlay').style.display = 'block';
            document.getElementById('simulationPanel').style.display = 'block';
            
            // Show results table immediately with placeholders
            const loadingElement = document.getElementById('simulationLoading');
            const tableElement = document.getElementById('comparisonTable');
            if (loadingElement) loadingElement.style.display = 'none';
            if (tableElement) tableElement.style.display = 'table';
            
            // Initialize table with grayed out rows
            const resultsElement = document.getElementById('comparisonResults');
            resultsElement.innerHTML = `
                <tr class="simulation-row grayed-out" id="simRow0">
                    <td class="comparison-variant">Base</td>
                    <td colspan="5">Running simulation...</td>
                </tr>
                <tr class="simulation-row grayed-out" id="simRow1">
                    <td class="comparison-variant">Scholar Only</td>
                    <td colspan="5">Waiting...</td>
                </tr>
                <tr class="simulation-row grayed-out" id="simRow2">
                    <td class="comparison-variant">Oracle Only</td>
                    <td colspan="5">Waiting...</td>
                </tr>
                <tr class="simulation-row grayed-out" id="simRow3">
                    <td class="comparison-variant">Scholar + Oracle</td>
                    <td colspan="5">Waiting...</td>
                </tr>
            `;
            
            // Start running simulations
            setTimeout(() => {
                runSimulationAsync();
            }, 100);
        }

        function closeSimulationPanel() {
            document.getElementById('simulationOverlay').style.display = 'none';
            document.getElementById('simulationPanel').style.display = 'none';
        }

        async function runSimulationAsync() {
            const variants = [
                { scholar: false, oracle: false, name: "Base", index: 0 },
                { scholar: true, oracle: false, name: "Scholar Only", index: 1 },
                { scholar: false, oracle: true, name: "Oracle Only", index: 2 },
                { scholar: true, oracle: true, name: "Scholar + Oracle", index: 3 }
            ];
            
            for (const variant of variants) {
                // Update status to "Running simulation..."
                const row = document.getElementById(`simRow${variant.index}`);
                row.innerHTML = `
                    <td class="comparison-variant">${variant.name}</td>
                    <td colspan="5">Running simulation...</td>
                `;
                
                // Run simulation asynchronously
                await new Promise(resolve => {
                    setTimeout(() => {
                        const results = simulateResearchPath(variant.scholar, variant.oracle, 1000);
                        
                        // Calculate statistics
                        const average = Math.round(results.reduce((a, b) => a + b, 0) / results.length);
                        const min = Math.min(...results);
                        const max = Math.max(...results);
                        const stdDev = Math.round(Math.sqrt(results.reduce((sq, n) => sq + Math.pow(n - average, 2), 0) / results.length));
                        const expectedMin = Math.max(min, average - stdDev);
                        const expectedMax = Math.min(max, average + stdDev);
                        
                        // Update row with results
                        row.classList.remove('grayed-out');
                        row.innerHTML = `
                            <td class="comparison-variant">${variant.name}</td>
                            <td>${min.toLocaleString()}</td>
                            <td>${max.toLocaleString()}</td>
                            <td><strong>${average.toLocaleString()}</strong></td>
                            <td>${stdDev.toLocaleString()}</td>
                            <td>${expectedMin.toLocaleString()} - ${expectedMax.toLocaleString()}</td>
                        `;
                        
                        resolve();
                    }, 100); // Small delay to show progress
                });
            }
        }
        
        function runSimulation() {
            // Show loading state
            const runButton = document.querySelector('.sim-run-button');
            const originalText = runButton.textContent;
            runButton.textContent = 'Running...';
            runButton.disabled = true;
            
            const loadingElement = document.getElementById('simulationLoading');
            const tableElement = document.getElementById('comparisonTable');
            if (loadingElement) loadingElement.style.display = 'block';
            if (tableElement) tableElement.style.display = 'none';
            
            // Run simulation after short delay to show loading state
            setTimeout(() => {
                const variants = [
                    { scholar: false, oracle: false, name: "Base" },
                    { scholar: true, oracle: false, name: "Scholar Only" },
                    { scholar: false, oracle: true, name: "Oracle Only" },
                    { scholar: true, oracle: true, name: "Scholar + Oracle" }
                ];
                
                const allResults = [];
                
                for (const variant of variants) {
                    console.log(`🚀 Starting variant: ${variant.name} (Scholar=${variant.scholar}, Oracle=${variant.oracle})`);
                    const results = simulateResearchPath(variant.scholar, variant.oracle, 1000);
                    console.log(`✅ Completed variant: ${variant.name}`, results);
                    allResults.push({
                        name: variant.name,
                        results: results
                    });
                }
                
                console.log('All simulation results:', allResults);
                displayComparisonResults(allResults);
                
                const loading = document.getElementById('simulationLoading');
                const panel = document.getElementById('simulationPanel');
                const overlay = document.getElementById('simulationOverlay');
                
                console.log('Elements found:');
                console.log('- loading element:', !!loading);
                console.log('- simulation panel:', !!panel);
                console.log('- simulation overlay:', !!overlay);
                
                if (panel) {
                    console.log('Panel display style:', panel.style.display);
                    console.log('Panel visibility:', panel.style.visibility);
                    console.log('Panel dimensions:', panel.offsetWidth, 'x', panel.offsetHeight);
                }
                
                if (loading) loading.style.display = 'none';
                console.log('Results should now be visible using div layout');
                
                // Hide the button after simulation is complete
                runButton.style.display = 'none';
            }, 100);
        }

        function simulateResearchPath(hasScholar, hasOracle, numSimulations) {
            const results = [];
            
            // Build research path from current selections, excluding starting techs
            const researchPath = [
                ...researchedTechs.filter(techId => !isStartingTech(techId)),
                ...researchedBonusTechs
            ];
            
            // Debug: Calculate expected cost and compare to UI
            let expectedCost = 0;
            researchedTechs.forEach(techId => {
                if (!isStartingTech(techId)) {
                    const tech = techData.techs.find(t => t.id === techId);
                    if (tech) expectedCost += tech.cost;
                }
            });
            researchedBonusTechs.forEach(bonusId => {
                const bonus = techData.bonusTechs.find(t => t.id === bonusId);
                if (bonus) expectedCost += bonus.cost;
            });
            
            console.log(`🔍 DEBUG: Expected total cost: ${expectedCost}`);
            console.log(`🔍 DEBUG: Research path: ${researchPath.length} techs`);
            console.log(`🔍 DEBUG: Main techs (non-starting): ${researchedTechs.filter(techId => !isStartingTech(techId)).length}`);
            console.log(`🔍 DEBUG: Bonus techs: ${researchedBonusTechs.length}`);
            
            // Enable detailed debugging for Scholar simulations only
            window.debugSimulation = hasScholar;
            // Special debug mode for Stone Boost issue
            window.debugStoneBoost = hasScholar;
            
            for (let sim = 0; sim < numSimulations; sim++) {
                if (sim === 0) {
                    window.verboseFirstTurn = true; // Extra verbose logging for first turn
                } else if (sim === 100) {
                    window.debugSimulation = false; // Turn off debugging after first 100 runs
                    window.debugStoneBoost = false; // Turn off Stone Boost debugging after first 100 runs
                    window.verboseFirstTurn = false;
                }
                const result = simulateSingleRun(researchPath, hasScholar, hasOracle);
                if (result.failed) {
                    results.push({ 
                        failed: true, 
                        reason: result.reason, 
                        missedCards: result.missedCards,
                        scholarRedraws: result.scholarRedraws, 
                        scholarRedrawsSuccessful: result.scholarRedrawsSuccessful 
                    });
                } else {
                    results.push({ 
                        cost: result.cost, 
                        scholarRedraws: result.scholarRedraws, 
                        scholarRedrawsSuccessful: result.scholarRedrawsSuccessful 
                    });
                }
            }
            
            // Separate successful and failed runs
            const successfulRuns = results.filter(r => !r.failed);
            const failedRuns = results.filter(r => r.failed);
            
            // Calculate Scholar redraw statistics
            const scholarStats = {
                totalRedraws: results.reduce((sum, r) => sum + (r.scholarRedraws || 0), 0),
                successfulRedraws: results.reduce((sum, r) => sum + (r.scholarRedrawsSuccessful || 0), 0),
                avgRedrawsPerRun: 0,
                redrawSuccessRate: 0
            };
            
            if (hasScholar && results.length > 0) {
                scholarStats.avgRedrawsPerRun = scholarStats.totalRedraws / results.length;
                if (scholarStats.totalRedraws > 0) {
                    scholarStats.redrawSuccessRate = scholarStats.successfulRedraws / scholarStats.totalRedraws;
                }
            }
            
            if (successfulRuns.length === 0) {
                return { 
                    min: 0, max: 0, avg: 0, stdDev: 0, 
                    successRate: 0, 
                    failureReasons: failedRuns.reduce((acc, fail) => {
                        acc[fail.reason] = (acc[fail.reason] || 0) + 1;
                        return acc;
                    }, {}),
                    results: results 
                };
            }
            
            // Calculate statistics for successful runs
            const costs = successfulRuns.map(r => r.cost);
            const sortedResults = costs.sort((a, b) => a - b);
            const min = sortedResults[0];
            const max = sortedResults[sortedResults.length - 1];
            const avg = costs.reduce((sum, cost) => sum + cost, 0) / costs.length;
            
            // Calculate standard deviation
            const variance = costs.reduce((sum, cost) => sum + Math.pow(cost - avg, 2), 0) / costs.length;
            const stdDev = Math.sqrt(variance);
            
            const successRate = successfulRuns.length / results.length;
            const failureReasons = failedRuns.reduce((acc, fail) => {
                acc[fail.reason] = (acc[fail.reason] || 0) + 1;
                return acc;
            }, {});
            
            // Track which specific bonus cards are missed
            const missedBonusCards = {};
            failedRuns.forEach(fail => {
                if (fail.reason === 'missed_bonus_cards' && fail.missedCards) {
                    fail.missedCards.forEach(cardId => {
                        missedBonusCards[cardId] = (missedBonusCards[cardId] || 0) + 1;
                    });
                }
            });
            
            return { min, max, avg, stdDev, successRate, failureReasons, results, scholarStats, missedBonusCards };
        }

        function isStartingTech(techId) {
            return selectedNation && 
                   nationData.startingTechs[selectedNation] && 
                   nationData.startingTechs[selectedNation].includes(techId);
        }

        function simulateSingleRun(researchPath, hasScholar, hasOracle) {
            let completedTechs = new Set();
            let removedBonusCards = new Set(); // Track permanently removed bonus cards
            let totalCost = 0;
            let turnCount = 0;
            let scholarRedraws = 0; // Track number of redraws
            let scholarRedrawsSuccessful = 0; // Track successful redraws (found target)
            
            // PERSISTENT draw and discard piles across all turns
            let drawPile = [];
            let discardPile = [];
            let techsAlreadyInDeck = new Set(); // Track which techs are already in the deck
            
            if (window.debugSimulation) {
                console.log(`🎲 Starting simulation: Scholar=${hasScholar}, Oracle=${hasOracle}`);
                console.log(`🎯 Target techs: ${researchPath.map(id => {
                    const mainTech = techData.techs.find(t => t.id === id);
                    const bonusTech = techData.bonusTechs.find(t => t.id === id);
                    return (mainTech || bonusTech)?.name || id;
                }).join(', ')}`);
            }
            
            // Add starting techs as already completed
            if (selectedNation && nationData.startingTechs[selectedNation]) {
                nationData.startingTechs[selectedNation].forEach(techId => {
                    completedTechs.add(techId);
                });
                if (window.debugSimulation) {
                    console.log(`🏛️ Starting techs: ${Array.from(completedTechs).map(id => {
                        const tech = techData.techs.find(t => t.id === id);
                        return tech?.name || id;
                    }).join(', ')}`);
                }
            }
            
            // Separate main techs and bonus cards in research path
            const targetMainTechs = researchPath.filter(id => techData.techs.some(t => t.id === id));
            const targetBonusCards = researchPath.filter(id => techData.bonusTechs.some(t => t.id === id));
            const targetTechSet = new Set(researchPath);
            
            if (window.debugSimulation && targetBonusCards.length > 0) {
                console.log(`🎁 Target bonus cards: ${targetBonusCards.map(id => {
                    const bonus = techData.bonusTechs.find(t => t.id === id);
                    return bonus?.name || id;
                }).join(', ')}`);
            }
            
            // Keep researching until all target techs are completed
            while (!isSubset(targetTechSet, completedTechs) && turnCount < 500) {
                turnCount++;
                
                // Check if any required bonus cards have been permanently removed
                const missedBonusCards = targetBonusCards.filter(id => removedBonusCards.has(id));
                if (missedBonusCards.length > 0) {
                    if (window.debugSimulation) {
                        console.warn(`💔 Failed: Required bonus cards permanently lost: ${missedBonusCards.map(id => {
                            const bonus = techData.bonusTechs.find(t => t.id === id);
                            return bonus?.name || id;
                        }).join(', ')}`);
                    }
                    return { cost: -1, failed: true, reason: 'missed_bonus_cards', missedCards: missedBonusCards };
                }
                
                // For turn 1 with a nation, only add Tier 1 techs and their bonus cards
                let availableTechs;
                if (turnCount === 1 && selectedNation) {
                    // First turn with nation: only Tier 1 techs not already owned
                    const tier1TechIds = ["TECH_IRONWORKING", "TECH_STONECUTTING", "TECH_TRAPPING", "TECH_DIVINATION", "TECH_ADMINISTRATION"];
                    availableTechs = techData.techs.filter(tech => {
                        return tier1TechIds.includes(tech.id) && !completedTechs.has(tech.id) && !isStartingTech(tech.id);
                    });
                    
                    // For Kush, also add the Stone Boost card since they start with Stonecutting
                    if (selectedNation === "NATION_KUSH") {
                        const stoneBoost = techData.bonusTechs.find(b => b.id === "TECH_STONECUTTING_BONUS_STONE");
                        if (stoneBoost && !removedBonusCards.has(stoneBoost.id)) {
                            stoneBoost.isBonus = true;
                            availableTechs.push(stoneBoost);
                        }
                    }
                } else {
                    // Normal turn: get all available techs based on prerequisites
                    availableTechs = getAvailableTechs(completedTechs, removedBonusCards);
                }
                
                // Only add NEW techs to the draw pile (techs that weren't available before)
                const newlyAvailableTechs = availableTechs.filter(tech => !techsAlreadyInDeck.has(tech.id));
                
                if (newlyAvailableTechs.length > 0) {
                    // Add new techs to draw pile and shuffle them in
                    newlyAvailableTechs.forEach(tech => {
                        techsAlreadyInDeck.add(tech.id);
                        drawPile.push(tech);
                    });
                    shuffleArray(drawPile);
                    
                    if (window.debugSimulation) {
                        console.log(`🆕 Added ${newlyAvailableTechs.length} newly available techs to draw pile`);
                        if (window.verboseFirstTurn && turnCount === 1) {
                            console.log(`  New techs: ${newlyAvailableTechs.map(t => `${t.name}(${t.cost})`).join(', ')}`);
                        }
                    }
                }
                
                if (window.debugSimulation && turnCount === 1) {
                    const mainCount = availableTechs.filter(t => !t.isBonus).length;
                    const bonusCount = availableTechs.filter(t => t.isBonus).length;
                    console.log(`📚 Total available techs: ${mainCount} main + ${bonusCount} bonus = ${availableTechs.length} total`);
                    
                    if (window.verboseFirstTurn) {
                        console.log(`\n🔍 VERBOSE: First Turn Draw Pile Details:`);
                        console.log(`Draw pile has ${drawPile.length} cards:`);
                        
                        // Group by type and cost
                        const mainTechs = drawPile.filter(t => !t.isBonus).sort((a, b) => a.cost - b.cost);
                        const bonusTechs = drawPile.filter(t => t.isBonus).sort((a, b) => a.cost - b.cost);
                        
                        console.log(`\n  Main Techs (${mainTechs.length}):`);
                        mainTechs.forEach(t => {
                            const isTarget = targetTechSet.has(t.id);
                            console.log(`    ${isTarget ? '🎯' : '  '} ${t.name} (${t.cost} 🧪) - ${t.id}`);
                        });
                        
                        console.log(`\n  Bonus Cards (${bonusTechs.length}):`);
                        bonusTechs.forEach(t => {
                            const isTarget = targetTechSet.has(t.id);
                            console.log(`    ${isTarget ? '🎯' : '  '} ${t.name} (${t.cost} 🧪) - ${t.id}`);
                        });
                        
                        console.log(`\nDiscard pile: ${discardPile.length} cards`);
                        console.log(`Target techs we're looking for: ${Array.from(targetTechSet).join(', ')}`);
                    }
                }
                
                // Research one tech this turn
                const result = researchOneTurn(targetTechSet, drawPile, discardPile, completedTechs, hasScholar, hasOracle, turnCount, removedBonusCards, { scholarRedraws, scholarRedrawsSuccessful });
                if (result.cost >= 0) {
                    totalCost += result.cost;
                    if (result.removedBonusCards) {
                        result.removedBonusCards.forEach(id => removedBonusCards.add(id));
                    }
                    // Update redraw tracking
                    if (result.redrawStats) {
                        scholarRedraws = result.redrawStats.scholarRedraws;
                        scholarRedrawsSuccessful = result.redrawStats.scholarRedrawsSuccessful;
                    }
                } else {
                    if (window.debugSimulation) {
                        console.warn('⚠️ No progress made this turn, ending simulation');
                    }
                    break;
                }
            }
            
            // Check final success/failure
            const success = isSubset(targetTechSet, completedTechs);
            
            if (window.debugSimulation) {
                console.log(`🏁 Simulation ${success ? 'SUCCESS' : 'FAILED'} after ${turnCount} turns, total cost: ${totalCost}`);
                if (!success) {
                    const remaining = Array.from(targetTechSet).filter(id => !completedTechs.has(id));
                    console.log(`❌ Missing techs: ${remaining.join(', ')}`);
                }
            }
            
            return success ? { 
                cost: totalCost, 
                failed: false,
                scholarRedraws,
                scholarRedrawsSuccessful
            } : { 
                cost: -1, 
                failed: true, 
                reason: 'incomplete', 
                totalCost,
                scholarRedraws,
                scholarRedrawsSuccessful
            };
        }

        function isSubset(subset, superset) {
            for (const item of subset) {
                if (!superset.has(item)) {
                    return false;
                }
            }
            return true;
        }

        function getAvailableTechs(completedTechs, removedBonusCards = new Set()) {
            const availableMainTechs = techData.techs.filter(tech => {
                // Skip if already completed or is a starting tech
                if (completedTechs.has(tech.id) || isStartingTech(tech.id)) {
                    return false;
                }
                
                // Check if all prerequisites are met
                return (tech.prereqs || []).every(prereqId => completedTechs.has(prereqId));
            });
            
            const availableBonusCards = techData.bonusTechs.filter(bonus => {
                // Skip if already completed or permanently removed
                if (completedTechs.has(bonus.id) || removedBonusCards.has(bonus.id)) {
                    return false;
                }
                
                // Filter by nation - same logic as initializeBonusTechs
                if (bonus.nation && (!selectedNation || bonus.nation !== selectedNation)) {
                    return false;
                }
                
                // Bonus cards require their parent tech to be completed
                if (bonus.parent && !completedTechs.has(bonus.parent)) {
                    return false;
                }
                
                return true;
            });
            
            // Mark bonus cards so we can identify them later
            availableBonusCards.forEach(bonus => {
                bonus.isBonus = true;
            });
            
            return [...availableMainTechs, ...availableBonusCards];
        }

        function researchOneTurn(targetTechSet, drawPile, discardPile, completedTechs, hasScholar, hasOracle, turnCount, removedBonusCards, redrawStats = { scholarRedraws: 0, scholarRedrawsSuccessful: 0 }) {
            const callId = Math.random().toString(36).substr(2, 9);
            if (window.debugStoneBoost) {
                console.log(`📞 FUNCTION CALL: researchOneTurn [Call ID: ${callId}] Turn ${turnCount}`);
            }
            if (window.debugSimulation) {
                console.log(`\n--- Turn ${turnCount} ---`);
                console.log(`📊 Draw pile: ${drawPile.length}, Discard pile: ${discardPile.length}, Completed: ${completedTechs.size}`);
                console.log(`🔮 Oracle: ${hasOracle ? 'YES (+1 card)' : 'NO'}, 📜 Scholar: ${hasScholar ? 'YES (redraw available)' : 'NO'}`);
                
                if (window.verboseFirstTurn && turnCount === 1) {
                    console.log(`\n🔍 VERBOSE: Draw/Discard State Before Drawing Hand:`);
                    console.log(`  Draw pile: ${drawPile.length} cards`);
                    console.log(`  Discard pile: ${discardPile.length} cards`);
                }
            }
            
            // Draw hand from available techs
            let hand = [];
            let expectedHandSize;
            if (turnCount === 1) {
                // Special handling for Turn 1 - guaranteed Tier 1 techs
                hand = drawFirstHand(drawPile, discardPile, hasOracle);
                expectedHandSize = hand.length; // First turn draws all available
            } else {
                // Normal draw for subsequent turns
                expectedHandSize = hasOracle ? 5 : 4;
                hand = drawHand(drawPile, discardPile, expectedHandSize);
            }
            
            if (hand.length === 0) {
                if (window.debugSimulation) {
                    console.warn('⚠️ No techs available to draw');
                }
                return { cost: 0, redrawStats };
            }
            
            if (window.debugSimulation && turnCount > 1 && window.debugStoneBoost) {
                console.log(`✋ Hand (${hand.length}/${expectedHandSize}): ${hand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
            }
            
            // Look for target techs in hand
            const targetsInHand = hand.filter(tech => targetTechSet.has(tech.id));
            const bonusTargetsInHand = targetsInHand.filter(tech => tech.isBonus);
            const mainTargetsInHand = targetsInHand.filter(tech => !tech.isBonus);
            
            // DEBUG: Special logging for Stone Boost case
            if (window.debugStoneBoost) {
                const stoneBoostInHand = hand.find(tech => tech.id === "TECH_STONECUTTING_BONUS_STONE");
                if (stoneBoostInHand) {
                    console.log(`🔍 STONE BOOST DEBUG: Stone Boost is in hand!`);
                    console.log(`  - Full hand: ${hand.map(t => t.name).join(', ')}`);
                    console.log(`  - Is Stone Boost a target? ${targetTechSet.has(stoneBoostInHand.id)}`);
                    console.log(`  - Target set contains: ${Array.from(targetTechSet).join(', ')}`);
                    console.log(`  - Stone Boost marked as bonus? ${stoneBoostInHand.isBonus}`);
                    console.log(`  - Targets in hand: ${targetsInHand.map(t => t.name).join(', ')}`);
                    console.log(`  - Bonus targets in hand: ${bonusTargetsInHand.map(t => t.name).join(', ')}`);
                    console.log(`  - Main targets in hand: ${mainTargetsInHand.map(t => t.name).join(', ')}`);
                }
            }
            
            let bestChoice = null;
            
            if (targetsInHand.length > 0) {
                // ALWAYS prioritize bonus cards since they're permanently lost if discarded
                if (bonusTargetsInHand.length > 0) {
                    if (bonusTargetsInHand.length > 1) {
                        if (window.debugSimulation) {
                            console.warn(`⚠️ Multiple target bonus cards in hand! Can only choose one:`);
                            bonusTargetsInHand.forEach(bonus => {
                                console.warn(`   - ${bonus.name}`);
                            });
                        }
                        // Choose the most expensive bonus card (arbitrary strategy)
                        bestChoice = bonusTargetsInHand.reduce((mostExpensive, bonus) => 
                            bonus.cost > mostExpensive.cost ? bonus : mostExpensive
                        );
                        if (window.debugSimulation) {
                            console.log(`🎯 Choosing most expensive bonus: ${bestChoice.name} (${bestChoice.cost} 🧪)`);
                        }
                    } else {
                        // Single bonus card - select it
                        bestChoice = bonusTargetsInHand[0];
                        if (window.debugSimulation) {
                            console.log(`🎁 Prioritizing bonus card: ${bestChoice.name} (bonus cards are lost if discarded)`);
                        }
                        if (window.debugStoneBoost && bestChoice.id === "TECH_STONECUTTING_BONUS_STONE") {
                            console.log(`✅ STONE BOOST SELECTED: Successfully choosing Stone Boost as priority bonus card!`);
                        }
                    }
                } else if (mainTargetsInHand.length > 0) {
                    // No bonus cards, pick the first main tech
                    bestChoice = mainTargetsInHand[0];
                    if (window.debugSimulation) {
                        console.log(`🔬 Found target main tech: ${bestChoice.name}`);
                    }
                    // This should never happen if Stone Boost is in hand as a target!
                    if (window.debugStoneBoost && hand.some(t => t.id === "TECH_STONECUTTING_BONUS_STONE")) {
                        console.log(`🚨 BUG: Choosing main tech ${bestChoice.name} when Stone Boost is in hand!`);
                        console.log(`  - bonusTargetsInHand.length = ${bonusTargetsInHand.length}`);
                        console.log(`  - bonusTargetsInHand = ${bonusTargetsInHand.map(t => t.name)}`);
                    }
                }
            } else {
                // No target tech in hand - consider Scholar redraw
                if (hasScholar && shouldRedrawForTargets(hand, targetTechSet, drawPile, discardPile)) {
                    redrawStats.scholarRedraws++;
                    if (window.debugSimulation) {
                        console.log(`📜 Scholar redraw #${redrawStats.scholarRedraws}: Looking for target techs...`);
                    }
                    
                    // Discard current hand and redraw
                    // IMPORTANT: Bonus cards are permanently removed, not discarded!
                    hand.forEach(tech => {
                        if (tech.isBonus) {
                            // Bonus cards are permanently removed when discarded
                            removedBonusCards.add(tech.id);
                            if (window.debugSimulation) {
                                console.log(`💔 Bonus card permanently removed during Scholar redraw: ${tech.name}`);
                            }
                            if (window.debugStoneBoost && tech.id === "TECH_STONECUTTING_BONUS_STONE") {
                                console.log(`🚨 STONE BOOST LOST IN REDRAW: Stone Boost was discarded during Scholar redraw!`);
                                console.log(`  - Was Stone Boost a target? ${targetTechSet.has(tech.id)}`);
                                console.log(`  - Why did we redraw with Stone Boost in hand?`);
                            }
                        } else {
                            // Main techs go to discard pile
                            discardPile.push(tech);
                        }
                    });
                    hand = drawHand(drawPile, discardPile, expectedHandSize);  // Update hand to the new draw
                    
                    if (window.debugSimulation) {
                        console.log(`✋ New hand (${hand.length}): ${hand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
                    }
                    
                    // Apply same target prioritization logic as main selection
                    const newTargetsInHand = hand.filter(tech => targetTechSet.has(tech.id));
                    const newBonusTargetsInHand = newTargetsInHand.filter(tech => tech.isBonus);
                    const newMainTargetsInHand = newTargetsInHand.filter(tech => !tech.isBonus);
                    
                    if (newTargetsInHand.length > 0) {
                        // ALWAYS prioritize bonus cards since they're permanently lost if discarded
                        if (newBonusTargetsInHand.length > 0) {
                            if (newBonusTargetsInHand.length > 1) {
                                // Choose the most expensive bonus card (arbitrary strategy)
                                bestChoice = newBonusTargetsInHand.reduce((mostExpensive, bonus) => 
                                    bonus.cost > mostExpensive.cost ? bonus : mostExpensive
                                );
                            } else {
                                // Single bonus card - select it
                                bestChoice = newBonusTargetsInHand[0];
                            }
                        } else {
                            // No bonus cards, pick the first main tech
                            bestChoice = newMainTargetsInHand[0];
                        }
                        
                        redrawStats.scholarRedrawsSuccessful++;
                        if (window.debugSimulation) {
                            const techType = bestChoice.isBonus ? '🎁 bonus' : '🔬 main';
                            console.log(`✅ Found target ${techType} in redraw! Selecting: ${bestChoice.name} (Success rate: ${redrawStats.scholarRedrawsSuccessful}/${redrawStats.scholarRedraws})`);
                        }
                    } else if (hand.length > 0) {
                        // Pick cheapest from new hand
                        // Even non-target bonus cards can be picked if they're cheapest
                        bestChoice = hand.reduce((cheapest, tech) => 
                            tech.cost < cheapest.cost ? tech : cheapest
                        );
                        if (window.debugSimulation) {
                            const techType = bestChoice.isBonus ? '🎁 bonus' : '🔬 main';
                            console.log(`💰 No target in redraw, picking cheapest ${techType}: ${bestChoice.name} (${bestChoice.cost} 🧪)`);
                        }
                    }
                } else {
                    // No redraw - pick cheapest to advance deck
                    // Even non-target bonus cards can be picked if they're cheapest
                    bestChoice = hand.reduce((cheapest, tech) => 
                        tech.cost < cheapest.cost ? tech : cheapest
                    );
                    if (window.debugSimulation) {
                        const techType = bestChoice.isBonus ? '🎁 bonus' : '🔬 main';
                        console.log(`💰 No target, picking cheapest ${techType}: ${bestChoice.name} (${bestChoice.cost} 🧪)`);
                    }
                }
            }
            
            if (bestChoice) {
                // DEBUG: Log what was actually selected
                if (window.debugStoneBoost && hand.some(t => t.id === "TECH_STONECUTTING_BONUS_STONE")) {
                    console.log(`🎯 FINAL SELECTION when Stone Boost in hand: ${bestChoice.name} [Call ID: ${callId}]`);
                    console.log(`  - bestChoice.id = ${bestChoice.id}`);
                    console.log(`  - Is this Stone Boost? ${bestChoice.id === "TECH_STONECUTTING_BONUS_STONE"}`);
                }
                
                completedTechs.add(bestChoice.id);
                
                // Handle discarded cards - bonus cards are permanently removed
                const removedThisTurn = [];
                hand.forEach(tech => {
                    if (tech.id !== bestChoice.id) {
                        if (tech.isBonus) {
                            // Bonus cards are permanently removed
                            removedBonusCards.add(tech.id);
                            removedThisTurn.push(tech.id);
                            if (window.debugSimulation) {
                                console.log(`💔 Bonus card permanently removed: ${tech.name}`);
                            }
                            if (window.debugStoneBoost && tech.id === "TECH_STONECUTTING_BONUS_STONE") {
                                console.log(`🚨 STONE BOOST LOST: Stone Boost was discarded instead of selected!`);
                                console.log(`  - Selected instead: ${bestChoice.name}`);
                                console.log(`  - Was Stone Boost a target? ${targetTechSet.has(tech.id)}`);
                            }
                        } else {
                            // Main techs go to discard pile
                            discardPile.push(tech);
                            if (window.verboseFirstTurn && window.debugSimulation) {
                                console.log(`♻️ Main tech discarded: ${tech.name} (${tech.cost} 🧪) -> discard pile`);
                            }
                        }
                    }
                });
                
                if (window.debugSimulation) {
                    const techType = bestChoice.isBonus ? '🎁 BONUS' : '🔬 MAIN';
                    console.log(`${techType} Researched: ${bestChoice.name} - now completed!`);
                    console.log(`📊 Post-research: Draw pile=${drawPile.length}, Discard pile=${discardPile.length}`);
                }
                
                return { 
                    cost: bestChoice.cost, 
                    removedBonusCards: removedThisTurn.length > 0 ? removedThisTurn : null,
                    redrawStats
                };
            }
            
            return { cost: 0, redrawStats };
        }

        function drawFirstHand(drawPile, discardPile, hasOracle) {
            // Special first draw rules:
            // - If nation selected: guaranteed ALL the Tier 1 techs that nation doesn't have
            //   - Most nations: 3 Tier 1 techs
            //   - Kush: 2 Tier 1 techs + Stone Boost bonus card
            // - If no nation: draw 5 cards including all Tier 1 techs
            // - Oracle doesn't affect first draw
            
            const hand = [];
            
            if (selectedNation) {
                // With a nation: draw ALL available cards (should be just the Tier 1s not owned)
                while (drawPile.length > 0) {
                    hand.push(drawPile.pop());
                }
            } else {
                // No nation selected - draw 5 cards
                for (let i = 0; i < 5 && drawPile.length > 0; i++) {
                    hand.push(drawPile.pop());
                }
            }
            
            if (window.debugSimulation) {
                console.log(`✋ First hand (${hand.length}): ${hand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
                if (selectedNation === "NATION_KUSH" && hand.some(t => t.id === "TECH_STONECUTTING_BONUS_STONE")) {
                    console.log(`  📜 Kush special: Includes Stone Boost bonus card`);
                }
            }
            
            return hand;
        }
        
        function drawHand(drawPile, discardPile, handSize) {
            const hand = [];
            
            for (let i = 0; i < handSize; i++) {
                // Reshuffle if draw pile is empty
                if (drawPile.length === 0 && discardPile.length > 0) {
                    if (window.debugSimulation) {
                        console.log(`🔄 Reshuffling: Moving ${discardPile.length} cards from discard to draw pile`);
                    }
                    drawPile.push(...discardPile);
                    discardPile.length = 0;
                    shuffleArray(drawPile);
                    if (window.debugSimulation) {
                        console.log(`🃏 Draw pile shuffled, now has ${drawPile.length} cards`);
                    }
                }
                
                // Draw from pile if available
                if (drawPile.length > 0) {
                    hand.push(drawPile.pop());
                }
            }
            
            return hand;
        }

        function shouldRedrawForTargets(hand, targetTechSet, drawPile, discardPile) {
            // Simple Scholar redraw logic: if we don't have a target and one exists, redraw!
            const allAvailableCards = [...drawPile, ...discardPile];
            const targetStillAvailable = allAvailableCards.some(tech => targetTechSet.has(tech.id));
            
            // Just redraw if any target is still available - be aggressive!
            const shouldRedraw = targetStillAvailable;
            
            if (window.debugSimulation) {
                const targetCount = allAvailableCards.filter(tech => targetTechSet.has(tech.id)).length;
                const targetProbability = targetCount / allAvailableCards.length;
                console.log(`📜 Scholar: ${targetCount} targets in ${allAvailableCards.length} cards (${Math.round(targetProbability*100)}% chance) - redraw=${shouldRedraw ? 'YES' : 'NO'}`);
            }
            
            return shouldRedraw;
        }


        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function displayComparisonResults(allResults) {
            console.log('displayComparisonResults called with:', allResults);
            
            // Try a different approach - replace the entire table with a simple div
            const container = document.getElementById('simulationResults');
            if (!container) {
                console.error('Could not find simulationResults container');
                console.log('Available elements with IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id));
                return;
            }
            
            console.log('Container found:', container);
            console.log('Container current content:', container.innerHTML);
            console.log('Container parent:', container.parentElement?.tagName, container.parentElement?.id);
            
            // Find min/max values for scaling
            const allMins = allResults.map(r => r.results.min);
            const allMaxs = allResults.map(r => r.results.max);
            const allAvgs = allResults.map(r => r.results.avg);
            const globalMin = Math.min(...allMins);
            const globalMax = Math.max(...allMaxs);
            const range = globalMax - globalMin;
            
            let html = `
                <div style="color: #d4af37; font-size: 1.1em; margin-bottom: 15px; text-align: center;">
                    📊 Research Cost Comparison (1000 runs each)
                </div>
                <div style="background: rgba(139, 105, 20, 0.15); padding: 15px; border-radius: 8px; border: 1px solid #8b6914;">
            `;
            
            for (const variant of allResults) {
                console.log(`Processing variant: ${variant.name}`, variant.results);
                const results = variant.results;
                // Ensure std dev bars don't go outside min/max bounds
                const rangeMin = Math.max(results.min, Math.round(results.avg - results.stdDev));
                const rangeMax = Math.min(results.max, Math.round(results.avg + results.stdDev));
                
                // Calculate bar widths as percentages
                const minPercent = ((results.min - globalMin) / range) * 100;
                const maxPercent = ((results.max - globalMin) / range) * 100;
                const avgPercent = ((results.avg - globalMin) / range) * 100;
                const stdDevLeftPercent = ((rangeMin - globalMin) / range) * 100;
                const stdDevRightPercent = ((rangeMax - globalMin) / range) * 100;
                
                // Build missed bonus cards string
                let missedCardsInfo = '';
                if (results.successRate < 1 && results.missedBonusCards && Object.keys(results.missedBonusCards).length > 0) {
                    const missedEntries = Object.entries(results.missedBonusCards).sort((a, b) => b[1] - a[1]);
                    
                    const missedList = missedEntries
                        .slice(0, 3) // Show top 3
                        .map(([cardId, count]) => {
                            const bonus = techData.bonusTechs.find(t => t.id === cardId);
                            const percentage = Math.round((count / 1000) * 100); // Percentage of total runs
                            return `${bonus?.name || cardId} (${percentage}%)`;
                        });
                    missedCardsInfo = ` (failed: ${missedList.join(', ')})`;
                }
                
                html += `
                    <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                        <div style="color: #d4af37; font-weight: bold; margin-bottom: 4px; font-size: 0.95em;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <span>${variant.name} <span style="font-weight: normal;">(<span style="color: var(--light-blue);">${Math.round(results.avg)}</span> <span style="color: var(--primary-gold);">± ${Math.round(results.stdDev)}</span>, range: <span style="color: var(--primary-green);">${results.min}</span>-<span style="color: var(--light-red);">${results.max}</span>)</span></span>
                                <div style="text-align: right;">
                                    <span style="color: ${results.successRate >= 0.95 ? 'var(--primary-green)' : results.successRate >= 0.8 ? 'var(--primary-gold)' : 'var(--light-red)'};">
                                        ${Math.round(results.successRate * 100)}% success${missedCardsInfo}
                                    </span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Bar chart with inline labels -->
                        <div style="position: relative; height: 45px; margin: 10px 0;">
                            <!-- Numbers positioned above the bar at their actual locations -->
                            ${(() => {
                                // Check for overlapping labels and only show distinct values
                                const labels = [
                                    { value: results.min, percent: minPercent, color: 'var(--primary-green)', type: 'min' },
                                    { value: Math.round(results.avg), percent: avgPercent, color: 'var(--light-blue)', type: 'avg' },
                                    { value: results.max, percent: maxPercent, color: 'var(--light-red)', type: 'max' }
                                ];
                                
                                // Sort by position
                                labels.sort((a, b) => a.percent - b.percent);
                                
                                let labelHtml = '';
                                const minSpacing = 5; // Minimum % spacing between labels
                                let lastShownLabel = null;
                                
                                for (let i = 0; i < labels.length; i++) {
                                    const label = labels[i];
                                    
                                    // Skip if too close to last shown label (within 5% and same value)
                                    if (lastShownLabel && 
                                        Math.abs(label.percent - lastShownLabel.percent) < minSpacing && 
                                        Math.abs(label.value - lastShownLabel.value) < 50) {
                                        continue; // Skip this label
                                    }
                                    
                                    labelHtml += `<div style="position: absolute; top: 0; left: ${label.percent}%; transform: translateX(-50%); color: ${label.color}; font-size: 0.75em; font-weight: bold;">
                                        ${label.value}
                                    </div>`;
                                    
                                    lastShownLabel = label;
                                }
                                
                                return labelHtml;
                            })()}
                            
                            <!-- Bar chart -->
                            <div style="position: absolute; top: 18px; width: 100%; height: 20px; background: rgba(0,0,0,0.5); border-radius: 10px; border: 1px solid #444;">
                                <!-- Min-Max range bar (light gray) -->
                                <div style="position: absolute; top: 6px; left: ${minPercent}%; width: ${maxPercent - minPercent}%; height: 8px; background: rgba(128,128,128,0.4); border-radius: 4px;"></div>
                                
                                <!-- StdDev range bar (gold) -->
                                <div style="position: absolute; top: 3px; left: ${stdDevLeftPercent}%; width: ${stdDevRightPercent - stdDevLeftPercent}%; height: 14px; background: var(--primary-gold); opacity: 0.6; border-radius: 7px;"></div>
                                
                                <!-- Average line (blue) -->
                                <div style="position: absolute; top: 2px; left: ${avgPercent}%; width: 3px; height: 16px; background: var(--light-blue); border-radius: 1px;"></div>
                                
                                <!-- Min marker (green) -->
                                <div style="position: absolute; top: 0; left: ${minPercent}%; width: 2px; height: 20px; background: var(--primary-green);"></div>
                                
                                <!-- Max marker (red) -->
                                <div style="position: absolute; top: 0; left: ${maxPercent}%; width: 2px; height: 20px; background: var(--light-red);"></div>
                            </div>
                            
                        </div>
                        
                    </div>
                `;
            }
            
            html += `
                <div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.75em; color: var(--text-muted); text-align: center;">
                    <strong>Legend:</strong> 
                    <span style="color: var(--primary-green);">Green</span> = Min | 
                    <span style="color: var(--light-blue);">Blue</span> = Average | 
                    <span style="color: var(--light-red);">Red</span> = Max | 
                    <span style="color: var(--primary-gold);">Gold bar</span> = ±1 Standard Deviation
                </div>
            `;
            container.innerHTML = html;
            
            // CRITICAL: Make sure the container itself is visible!
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.opacity = '1';
            
            console.log('Results displayed using div layout instead of table');
            console.log('Container display set to:', container.style.display);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            drawConnections();
        });
        
        // Handle scrolling to update arrow positions
        let scrollTimeout;
        const handleScroll = () => {
            // Clear existing timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            // Set a new timeout to redraw after scrolling stops
            scrollTimeout = setTimeout(() => {
                drawConnections();
            }, 100); // Redraw 100ms after scrolling stops
        };
        
        // Listen for various scroll and touch events
        window.addEventListener('scroll', handleScroll, { passive: true });
        document.addEventListener('scroll', handleScroll, { passive: true });
        
        // For mobile touch events
        let touchMoveTimeout;
        document.addEventListener('touchmove', () => {
            if (touchMoveTimeout) {
                clearTimeout(touchMoveTimeout);
            }
            touchMoveTimeout = setTimeout(() => {
                drawConnections();
            }, 100);
        }, { passive: true });
        
        // Also redraw when touch ends
        document.addEventListener('touchend', () => {
            setTimeout(() => {
                drawConnections();
            }, 50);
        }, { passive: true });

        // Initialize the tech tree when page loads
        window.addEventListener('load', initializeTechTree);
    </script>
</body>
</html>