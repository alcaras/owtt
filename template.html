<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Old World Tech Tree</title>
    <script src="https://cdn.jsdelivr.net/npm/leader-line@1.0.7/leader-line.min.js"></script>
    <link rel="stylesheet" href="styles.css">

</head>
<body>
    <div class="main-container">
        <div class="tech-tree-wrapper">
            <div class="tech-cost-headers">
                <div class="tech-cost-header">80 üß™</div>
                <div class="tech-cost-header">120 üß™</div>
                <div class="tech-cost-header">200 üß™</div>
                <div class="tech-cost-header">400 üß™</div>
                <div class="tech-cost-header">600 üß™</div>
                <div class="tech-cost-header">1000 üß™</div>
                <div class="tech-cost-header">1600 üß™</div>
                <div class="tech-cost-header">2000 üß™</div>
            </div>
            <div class="tech-tree" id="techTree"></div>
            
            <div class="bonus-tech-section">
                <h3>üíé Bonus Cards</h3>
                <div class="bonus-tech-grid" id="bonusTechGrid"></div>
            </div>
        </div>
    </div>

    <div class="sidebar">
        <div class="share-section">
            <button class="share-button" onclick="shareBuild()">Share Build</button>
        </div>
        
        <div class="nation-section">
            <h2>Nation</h2>
            <select class="nation-select" id="nationSelect" onchange="selectNation()">
                <option value="">No Nation</option>
                <option value="NATION_AKSUM">Aksum</option>
                <option value="NATION_ASSYRIA">Assyria</option>
                <option value="NATION_BABYLONIA">Babylonia</option>
                <option value="NATION_CARTHAGE">Carthage</option>
                <option value="NATION_EGYPT">Egypt</option>
                <option value="NATION_GREECE">Greece</option>
                <option value="NATION_HITTITE">Hittites</option>
                <option value="NATION_KUSH">Kush</option>
                <option value="NATION_PERSIA">Persia</option>
                <option value="NATION_ROME">Rome</option>
            </select>
        </div>
        
        <h2>Research Order</h2>
        <button class="simulate-button" onclick="openSimulationPanel()">üé≤ Simulate Research</button>
        <div class="total-cost" id="totalCost">Total Cost: 0</div>
        <div class="total-laws" id="totalLaws">Laws Available: 0</div>
        <div class="tech-order-list" id="techOrderList"></div>
        
        <button class="clear-button" onclick="clearBuild()">Clear All</button>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Simulation Panel -->
    <div class="simulation-overlay" id="simulationOverlay" onclick="closeSimulationPanel()"></div>
    <div class="simulation-panel" id="simulationPanel">
        <button onclick="closeSimulationPanel()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; color: var(--primary-gold); font-size: 24px; cursor: pointer; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background 0.2s;" onmouseover="this.style.background='rgba(212, 175, 55, 0.2)'" onmouseout="this.style.background='none'">√ó</button>
        
        <h3>üé≤ Research Simulation Comparison</h3>
        <p style="color: #f4e4c1; margin-bottom: 15px; text-align: center; font-size: 0.9em;">
            Running 1000 simulations for each Scholar/Oracle combination to compare variance in research costs.
        </p>
        
        <div class="simulation-buttons" style="margin-bottom: 15px; text-align: center;">
            <button class="sim-run-button" onclick="runSimulation()">Run All Simulations</button>
        </div>
        
        <div class="simulation-comparison" id="simulationResults">
            <div class="comparison-loading" id="simulationLoading" style="display: none;">
                üîÑ Running simulations... This may take a few moments.
            </div>
            <table class="comparison-table" id="comparisonTable">
                <thead>
                    <tr>
                        <th>Configuration</th>
                        <th>Min Cost</th>
                        <th>Max Cost</th>
                        <th>Average Cost</th>
                        <th>Std Dev</th>
                        <th>Expected Range</th>
                    </tr>
                </thead>
                <tbody id="comparisonResults">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Complete tech tree data from game files with correct prerequisites and unlocks
        {{TECH_DATA}}

        let researchedTechs = [];
        let researchOrder = [];
        let researchedBonusTechs = [];
        let selectedNation = '';

        // localStorage functions
        function saveToLocalStorage() {
            const state = {
                researchedTechs: researchedTechs,
                researchOrder: researchOrder,
                researchedBonusTechs: researchedBonusTechs,
                selectedNation: selectedNation,
                timestamp: Date.now()
            };
            localStorage.setItem('owtt-state', JSON.stringify(state));
        }

        function loadFromLocalStorage() {
            try {
                const stored = localStorage.getItem('owtt-state');
                if (stored) {
                    const state = JSON.parse(stored);
                    
                    // Restore state
                    researchedTechs = state.researchedTechs || [];
                    researchOrder = state.researchOrder || [];
                    researchedBonusTechs = state.researchedBonusTechs || [];
                    selectedNation = state.selectedNation || '';
                    
                    // Update UI
                    if (selectedNation) {
                        const select = document.getElementById('nationSelect');
                        if (select) {
                            select.value = selectedNation;
                        }
                    }
                    
                    console.log('Loaded state from localStorage:', state);
                    return true;
                }
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
            }
            return false;
        }

        function clearLocalStorage() {
            localStorage.removeItem('owtt-state');
        }

        // Nation lookup array for URL indices
        const nationLookup = [
            "NATION_AKSUM",
            "NATION_ASSYRIA", 
            "NATION_BABYLONIA",
            "NATION_CARTHAGE",
            "NATION_EGYPT",
            "NATION_GREECE",
            "NATION_HITTITE",
            "NATION_KUSH",
            "NATION_PERSIA",
            "NATION_ROME"
        ];

        {{NATION_DATA}}

        function initializeTechTree() {
            const techTree = document.getElementById('techTree');
            techTree.innerHTML = '';
            
            // Add tech nodes
            techData.techs.forEach(tech => {
                const node = document.createElement('div');
                node.className = 'tech-node';
                node.id = tech.id;
                node.style.gridColumn = tech.column + 1;
                node.style.gridRow = tech.row + 1;
                
                // Build unlocks display with emojis
                let unlocksHtml = '';
                const allUnlocks = [];
                
                if (tech.unlocks.units?.length > 0) {
                    tech.unlocks.units.forEach(unit => {
                        allUnlocks.push(`<span class="unlock-item">‚öîÔ∏è${unit}</span>`);
                    });
                }
                if (tech.unlocks.improvements?.length > 0) {
                    tech.unlocks.improvements.forEach(improvement => {
                        // Only show Kushite Pyramids if Kush is selected
                        if (improvement === "Kushite Pyramids" && selectedNation !== "NATION_KUSH") {
                            return;
                        }
                        allUnlocks.push(`<span class="unlock-item">üèóÔ∏è${improvement}</span>`);
                    });
                }
                if (tech.unlocks.laws?.length > 0) {
                    tech.unlocks.laws.forEach(law => {
                        allUnlocks.push(`<span class="unlock-item">‚öñÔ∏è${law}</span>`);
                    });
                }
                if (tech.unlocks.projects?.length > 0) {
                    tech.unlocks.projects.forEach(project => {
                        allUnlocks.push(`<span class="unlock-item">üèõÔ∏è${project}</span>`);
                    });
                }
                
                // Check if this tech has bonus techs available and add to unlocks
                const bonusTechs = techData.bonusTechs.filter(bonus => {
                    if (bonus.parent !== tech.id) return false;
                    // Only show nation-specific bonus cards if that nation is selected
                    if (bonus.nation && bonus.nation !== selectedNation) return false;
                    return true;
                });
                if (bonusTechs.length > 0) {
                    bonusTechs.forEach(bonusTech => {
                        // Use person emoji for courtiers, diamond for others
                        const isCourtier = bonusTech.name.includes('Minister') || 
                                         bonusTech.name.includes('Scientist') || 
                                         bonusTech.name.includes('Court Soldier') ||
                                         bonusTech.name.includes('Merchant');
                        const emoji = isCourtier ? 'üë§' : 'üíé';
                        allUnlocks.push(`<span class="unlock-item">${emoji}${bonusTech.name}</span>`);
                    });
                }
                
                if (allUnlocks.length > 0) {
                    unlocksHtml = `<div class="tech-unlocks">${allUnlocks.join('')}</div>`;
                }
                
                node.innerHTML = `
                    <div class="tech-name">${tech.name}</div>
                    ${unlocksHtml}
                `;
                
                node.addEventListener('click', () => toggleResearch(tech.id));
                node.addEventListener('mouseenter', (e) => showTooltip(e, tech));
                node.addEventListener('mouseleave', hideTooltip);
                
                techTree.appendChild(node);
            });
            
            // Initialize bonus tech section
            initializeBonusTechs();
            
            // Load state: URL params take priority over localStorage
            const urlParams = new URLSearchParams(window.location.search);
            const hasUrlParams = urlParams.has('n') || urlParams.has('nation') || urlParams.has('t') || urlParams.has('techs') || urlParams.has('b') || urlParams.has('bonus');
            
            if (hasUrlParams) {
                // Load from URL if present (for sharing links)
                loadFromUrl();
            } else {
                // Load from localStorage if no URL params
                loadFromLocalStorage();
            }
            
            updateTechStates();
            updateOrderList();
            drawConnections();
        }

        function initializeBonusTechs() {
            const bonusTechGrid = document.getElementById('bonusTechGrid');
            bonusTechGrid.innerHTML = '';
            
            // Filter bonus techs based on selected nation
            const availableBonusTechs = techData.bonusTechs.filter(bonusTech => {
                // Show general bonus techs (no nation property)
                if (!bonusTech.nation) return true;
                // Show nation-specific bonus techs only if nation is selected and matches
                return selectedNation && bonusTech.nation === selectedNation;
            });
            
            // Group bonus techs by cost
            const costGroups = {};
            availableBonusTechs.forEach(bonusTech => {
                if (!costGroups[bonusTech.cost]) {
                    costGroups[bonusTech.cost] = [];
                }
                costGroups[bonusTech.cost].push(bonusTech);
            });
            
            // Sort cost groups by cost
            const sortedCosts = Object.keys(costGroups).map(Number).sort((a, b) => a - b);
            
            sortedCosts.forEach(cost => {
                // Create cost group container
                const costGroup = document.createElement('div');
                costGroup.className = 'bonus-cost-group';
                
                // Add cost header  
                const costHeader = document.createElement('div');
                costHeader.className = 'bonus-cost-header';
                costHeader.textContent = `${cost} üß™`;
                costGroup.appendChild(costHeader);
                
                // Add cards column
                const cardsColumn = document.createElement('div');
                cardsColumn.className = 'bonus-cards-column';
                
                costGroups[cost].forEach(bonusTech => {
                    const node = document.createElement('div');
                    node.className = 'bonus-tech-node';
                    node.id = bonusTech.id;
                    
                    node.innerHTML = `
                        <div class="bonus-tech-name">${bonusTech.name}</div>
                        <div class="bonus-tech-parent">${bonusTech.bonus}</div>
                    `;
                    
                    node.addEventListener('click', () => toggleBonusResearch(bonusTech.id));
                    node.addEventListener('mouseenter', (e) => showBonusTooltip(e, bonusTech));
                    node.addEventListener('mouseleave', hideTooltip);
                    
                    cardsColumn.appendChild(node);
                });
                
                costGroup.appendChild(cardsColumn);
                bonusTechGrid.appendChild(costGroup);
            });
            
            updateBonusTechStates();
        }

        function toggleBonusResearch(bonusTechId) {
            const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
            if (!bonusTech) return;

            const index = researchedBonusTechs.indexOf(bonusTechId);
            if (index > -1) {
                // Remove bonus tech
                researchedBonusTechs.splice(index, 1);
            } else {
                // Add the parent tech and all its prerequisites first
                if (!researchedTechs.includes(bonusTech.parent)) {
                    // Add prerequisites of the parent tech using proper insertion order
                    const prereqsToAdd = getAllPrerequisites(bonusTech.parent);
                    prereqsToAdd.forEach(prereqId => {
                        if (!researchedTechs.includes(prereqId)) {
                            // Find the correct insertion point to maintain tech tree order
                            const insertIndex = findInsertionIndex(prereqId);
                            researchedTechs.splice(insertIndex, 0, prereqId);
                            researchOrder.splice(insertIndex, 0, Date.now() - (prereqsToAdd.length - prereqsToAdd.indexOf(prereqId)) * 1000);
                        }
                    });
                    
                    // Add the parent tech itself in the correct position
                    const parentInsertIndex = findInsertionIndex(bonusTech.parent);
                    researchedTechs.splice(parentInsertIndex, 0, bonusTech.parent);
                    researchOrder.splice(parentInsertIndex, 0, Date.now() - 500);
                }
                
                // Now add the bonus tech
                researchedBonusTechs.push(bonusTechId);
            }
            
            updateTechStates(); // Update main tech states too since we may have added main techs
            updateBonusTechStates();
            updateOrderList();
            drawConnections(); // Redraw connections since main techs may have changed
            saveToLocalStorage(); // Save state after changes
        }

        function updateBonusTechStates() {
            // Filter bonus techs based on selected nation - same logic as initializeBonusTechs
            const availableBonusTechs = techData.bonusTechs.filter(bonusTech => {
                // Show general bonus techs (no nation property)
                if (!bonusTech.nation) return true;
                // Show nation-specific bonus techs only if nation is selected and matches
                return selectedNation && bonusTech.nation === selectedNation;
            });
            
            availableBonusTechs.forEach(bonusTech => {
                const node = document.getElementById(bonusTech.id);
                if (node) {
                    node.classList.remove('available', 'researched');
                    
                    // Remove existing order badge
                    const existingBadge = node.querySelector('.tech-order-badge');
                    if (existingBadge) {
                        existingBadge.remove();
                    }
                    
                    if (researchedBonusTechs.includes(bonusTech.id)) {
                        node.classList.add('researched');
                        
                        // Add order badge - calculate position in overall research order
                        const allResearched = [...researchedTechs, ...researchedBonusTechs];
                        const overallIndex = allResearched.indexOf(bonusTech.id);
                        if (overallIndex > -1) {
                            const badge = document.createElement('div');
                            badge.className = 'tech-order-badge';
                            badge.textContent = overallIndex + 1;
                            node.appendChild(badge);
                        }
                    } else if (researchedTechs.includes(bonusTech.parent)) {
                        node.classList.add('available');
                    }
                }
            });
        }

        function showBonusTooltip(event, bonusTech) {
            const tooltip = document.getElementById('tooltip');
            const parentTech = techData.techs.find(t => t.id === bonusTech.parent);
            const parentName = parentTech ? parentTech.name : bonusTech.parent;
            
            tooltip.innerHTML = `
                <h3>${bonusTech.name}</h3>
                <p><strong>Cost:</strong> ${bonusTech.cost} Science</p>
                <p><strong>Requires:</strong> ${parentName}</p>
                <p><strong>Bonus:</strong> ${bonusTech.bonus}</p>
                <p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to toggle research</p>
            `;
            
            // Position tooltip accounting for scroll and viewport bounds
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // Check if tooltip would go off screen and adjust
            const viewportWidth = window.innerWidth;
            
            // If too far right, position to left of element
            if (left + 300 > viewportWidth + scrollLeft) {
                left = rect.left + scrollLeft - 310;
            }
            
            // If too high (near top), position below element
            if (rect.top < 150) {
                top = rect.bottom + scrollTop + 10;
            }
            
            // Ensure tooltip doesn't go above the viewport
            if (top < scrollTop + 10) {
                top = scrollTop + 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.add('show');
        }

        function toggleResearch(techId) {
            const index = researchedTechs.indexOf(techId);
            if (index > -1) {
                // Remove this tech and all techs that depend on it
                const techsToRemove = getTechsToRemove(techId);
                researchedTechs = researchedTechs.filter(id => !techsToRemove.includes(id));
                researchOrder = researchOrder.slice(0, researchedTechs.length);
            } else {
                // Add this tech and all its prerequisites
                const prereqsToAdd = getAllPrerequisites(techId);
                prereqsToAdd.forEach(prereqId => {
                    if (!researchedTechs.includes(prereqId)) {
                        researchedTechs.push(prereqId);
                        researchOrder.push(Date.now());
                    }
                });
                
                // Add the clicked tech itself if not already added
                if (!researchedTechs.includes(techId)) {
                    researchedTechs.push(techId);
                    researchOrder.push(Date.now());
                }
            }
            updateTechStates();
            updateBonusTechStates(); // Update bonus techs when main techs change
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after changes
        }

        function getAllPrerequisites(techId) {
            const visited = new Set();
            const result = [];
            
            // Get starting techs for current nation
            const startingTechs = selectedNation && nationData.startingTechs[selectedNation] 
                ? new Set(nationData.startingTechs[selectedNation]) 
                : new Set();
            
            function addPrereqs(id) {
                if (visited.has(id)) return;
                visited.add(id);
                
                // Skip if this is a starting tech (already have it)
                if (startingTechs.has(id)) return;
                
                const tech = techData.techs.find(t => t.id === id);
                if (!tech) return;
                
                // First add all prerequisites of this tech
                tech.prereqs.forEach(prereqId => {
                    // Skip if this prerequisite is a starting tech (already have it)
                    if (!startingTechs.has(prereqId)) {
                        addPrereqs(prereqId);
                    }
                });
                
                // Then add this tech (ensuring prerequisites come first)
                if (!result.includes(id)) {
                    result.push(id);
                }
            }
            
            const tech = techData.techs.find(t => t.id === techId);
            if (tech) {
                tech.prereqs.forEach(prereqId => {
                    // Skip if this prerequisite is a starting tech (already have it)
                    if (!startingTechs.has(prereqId)) {
                        addPrereqs(prereqId);
                    }
                });
            }
            
            return result;
        }
        
        function findInsertionIndex(techId) {
            // Find the correct position to insert a tech to maintain tech tree order
            // Insert after all prerequisites but before any techs that depend on this one
            
            const tech = techData.techs.find(t => t.id === techId);
            if (!tech) return researchedTechs.length;
            
            // Find latest prerequisite position
            let latestPrereqIndex = -1;
            tech.prereqs.forEach(prereqId => {
                const prereqIndex = researchedTechs.indexOf(prereqId);
                if (prereqIndex > latestPrereqIndex) {
                    latestPrereqIndex = prereqIndex;
                }
            });
            
            // Insert after the latest prerequisite
            return latestPrereqIndex + 1;
        }

        function getTechsToRemove(techId) {
            const toRemove = new Set([techId]);
            let changed = true;
            
            // Get starting techs for current nation - these should never be removed
            const startingTechs = selectedNation && nationData.startingTechs[selectedNation] 
                ? new Set(nationData.startingTechs[selectedNation]) 
                : new Set();
            
            // Keep finding techs that depend on techs we're removing
            while (changed) {
                changed = false;
                researchedTechs.forEach(id => {
                    if (!toRemove.has(id) && !startingTechs.has(id)) { // Never remove starting techs
                        const tech = techData.techs.find(t => t.id === id);
                        if (tech && tech.prereqs.some(prereq => toRemove.has(prereq))) {
                            // Check if this tech has alternative paths through starting techs
                            const hasAlternativePath = tech.prereqs.some(prereq => {
                                // If this prerequisite is being removed, check if we can reach this tech through starting techs
                                if (toRemove.has(prereq)) {
                                    return startingTechs.size > 0 && Array.from(startingTechs).some(startingTech => {
                                        return canReachTech(startingTech, id, new Set());
                                    });
                                }
                                return true; // This prerequisite is not being removed
                            });
                            
                            // Only remove if no alternative path exists
                            if (!hasAlternativePath) {
                                toRemove.add(id);
                                changed = true;
                            }
                        }
                    }
                });
            }
            
            return Array.from(toRemove);
        }

        function updateTechStates() {
            techData.techs.forEach(tech => {
                const node = document.getElementById(tech.id);
                node.classList.remove('researched', 'available');
                
                // Remove order badge
                const existingBadge = node.querySelector('.tech-order-badge');
                if (existingBadge) {
                    existingBadge.remove();
                }
                
                const techIndex = researchedTechs.indexOf(tech.id);
                if (techIndex > -1) {
                    node.classList.add('researched');
                    // Add order badge
                    const badge = document.createElement('div');
                    badge.className = 'tech-order-badge';
                    badge.textContent = techIndex + 1;
                    node.appendChild(badge);
                } else if (isAvailable(tech)) {
                    node.classList.add('available');
                }
            });
        }

        function isAvailable(tech) {
            return tech.prereqs.every(prereq => researchedTechs.includes(prereq));
        }

        function updateOrderList() {
            const list = document.getElementById('techOrderList');
            const totalCostElement = document.getElementById('totalCost');
            const totalLawsElement = document.getElementById('totalLaws');
            list.innerHTML = '';
            
            let totalCost = 0;
            let totalLaws = 0;
            let itemIndex = 1;
            
            // Create unified ordering: combine main techs with their associated bonus techs
            const unifiedOrder = [];
            
            // Add main techs in order
            researchedTechs.forEach((techId) => {
                unifiedOrder.push({ type: 'main', id: techId });
                
                // Add any bonus techs that belong to this main tech
                researchedBonusTechs.forEach((bonusTechId) => {
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    if (bonusTech && bonusTech.parent === techId) {
                        unifiedOrder.push({ type: 'bonus', id: bonusTechId });
                    }
                });
            });
            
            // Process the unified order
            unifiedOrder.forEach((item) => {
                if (item.type === 'main') {
                    const techId = item.id;
                const tech = techData.techs.find(t => t.id === techId);
                const isStartingTech = selectedNation && 
                    nationData.startingTechs[selectedNation] && 
                    nationData.startingTechs[selectedNation].includes(techId);
                
                if (!isStartingTech) {
                    totalCost += tech.cost;
                }
                
                // Count laws from this tech
                const hasLaws = tech.unlocks && tech.unlocks.laws && tech.unlocks.laws.length > 0;
                if (hasLaws) {
                    totalLaws += tech.unlocks.laws.length;
                }
                
                const listItem = document.createElement('div');
                listItem.className = 'tech-order-item';
                listItem.setAttribute('data-tech-id', techId);
                listItem.style.cursor = 'pointer';
                
                // Add law icon at the front if this tech unlocks laws
                const lawIcon = hasLaws ? '‚öñÔ∏è ' : '';
                
                if (isStartingTech) {
                    listItem.innerHTML = `
                        <span class="tech-order-number">${itemIndex}.</span>
                        <span class="tech-order-name">${lawIcon}${tech.name}</span>
                        <span class="tech-order-cost"><span style="text-decoration: line-through; color: #888;">${tech.cost}</span> <strong style="color: #5a8a3a;">FREE</strong></span>
                    `;
                } else {
                    listItem.innerHTML = `
                        <span class="tech-order-number">${itemIndex}.</span>
                        <span class="tech-order-name">${lawIcon}${tech.name}</span>
                        <span class="tech-order-cost">${tech.cost}</span>
                    `;
                }
                
                // Add hover events for tooltip
                listItem.addEventListener('mouseenter', (e) => {
                    console.log('Tech tooltip triggered for:', tech.name);
                    showTooltip(e, tech);
                });
                listItem.addEventListener('mouseleave', hideTooltip);
                
                list.appendChild(listItem);
                itemIndex++;
                } else if (item.type === 'bonus') {
                    const bonusTechId = item.id;
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    totalCost += bonusTech.cost;
                    
                    const listItem = document.createElement('div');
                    listItem.className = 'tech-order-item';
                    listItem.setAttribute('data-bonus-tech-id', bonusTechId);
                    listItem.style.backgroundColor = 'rgba(180, 160, 55, 0.2)'; // Highlight bonus techs
                    listItem.style.cursor = 'pointer';
                    listItem.innerHTML = `
                        <span class="tech-order-number">${itemIndex}.</span>
                        <span class="tech-order-name">üíé ${bonusTech.name}</span>
                        <span class="tech-order-cost">${bonusTech.cost}</span>
                    `;
                    
                    // Add hover events for bonus tech tooltip
                    listItem.addEventListener('mouseenter', (e) => {
                        console.log('Bonus tooltip triggered for:', bonusTech.name);
                        showBonusTooltip(e, bonusTech);
                    });
                    listItem.addEventListener('mouseleave', hideTooltip);
                    
                    list.appendChild(listItem);
                    itemIndex++;
                }
            });
            
            totalCostElement.textContent = `Total Cost: ${totalCost}`;
            totalLawsElement.textContent = `Laws Available: ${totalLaws}`;
            
            // Update clear button state
            const clearButton = document.querySelector('.clear-button');
            if (researchedTechs.length === 0 && researchedBonusTechs.length === 0) {
                clearButton.classList.add('disabled');
            } else {
                clearButton.classList.remove('disabled');
            }
        }

        let connections = []; // Store line objects for cleanup
        
        function drawConnections() {
            // Remove existing connections
            connections.forEach(line => line.remove());
            connections = [];
            
            // Draw connections using Leader Line (only for main techs, not bonus techs)
            techData.techs.forEach(tech => {
                if (tech.prereqs.length > 0) {
                    const toNode = document.getElementById(tech.id);
                    if (!toNode) return;
                    
                    tech.prereqs.forEach(prereqId => {
                        const fromNode = document.getElementById(prereqId);
                        if (fromNode) {
                            // Determine line color based on research status
                            let lineColor = '#4a3426'; // default
                            if (researchedTechs.includes(prereqId) && researchedTechs.includes(tech.id)) {
                                lineColor = '#5a8a3a'; // both researched
                            } else if (researchedTechs.includes(prereqId) && isAvailable(tech)) {
                                lineColor = '#b4a037'; // prereq researched, target available
                            }
                            
                            // Create line using Leader Line
                            const line = new LeaderLine(fromNode, toNode, {
                                color: lineColor,
                                size: 2,
                                path: 'straight',
                                startSocket: 'right',
                                endSocket: 'left',
                                startSocketGravity: 100,
                                endSocketGravity: 100
                            });
                            
                            connections.push(line);
                        }
                    });
                }
            });
        }

        function showTooltip(event, tech) {
            const tooltip = document.getElementById('tooltip');
            const prereqNames = tech.prereqs.map(id => {
                const prereqTech = techData.techs.find(t => t.id === id);
                return prereqTech ? prereqTech.name : id;
            }).join(', ');
            
            let unlocksList = '';
            const hasUnlocks = tech.unlocks.units?.length > 0 || tech.unlocks.projects?.length > 0 || 
                              tech.unlocks.improvements?.length > 0 || tech.unlocks.laws?.length > 0;
            const hasBonusTechs = techData.bonusTechs.some(bonus => {
                if (bonus.parent !== tech.id) return false;
                // Only count nation-specific bonus techs if that nation is selected
                if (bonus.nation && bonus.nation !== selectedNation) return false;
                return true;
            });
            
            if (hasUnlocks || hasBonusTechs) {
                unlocksList = '<div class="unlocks-list"><h4>Unlocks:</h4><ul>';
                if (tech.unlocks.units?.length > 0) {
                    tech.unlocks.units.forEach(unit => {
                        unlocksList += `<li>‚öîÔ∏è ${unit}</li>`;
                    });
                }
                if (tech.unlocks.improvements?.length > 0) {
                    tech.unlocks.improvements.forEach(improvement => {
                        // Only show Kushite Pyramids if Kush is selected
                        if (improvement === "Kushite Pyramids" && selectedNation !== "NATION_KUSH") {
                            return;
                        }
                        unlocksList += `<li>üèóÔ∏è ${improvement}</li>`;
                    });
                }
                if (tech.unlocks.laws?.length > 0) {
                    tech.unlocks.laws.forEach(law => {
                        unlocksList += `<li>‚öñÔ∏è ${law}</li>`;
                    });
                }
                if (tech.unlocks.projects?.length > 0) {
                    tech.unlocks.projects.forEach(project => {
                        unlocksList += `<li>üèõÔ∏è ${project}</li>`;
                    });
                }
                if (hasBonusTechs) {
                    const bonusTechs = techData.bonusTechs.filter(bonus => {
                        if (bonus.parent !== tech.id) return false;
                        // Only show nation-specific bonus techs if that nation is selected
                        if (bonus.nation && bonus.nation !== selectedNation) return false;
                        return true;
                    });
                    bonusTechs.forEach(bonusTech => {
                        unlocksList += `<li>üíé ${bonusTech.name}</li>`;
                    });
                }
                unlocksList += '</ul></div>';
            }
            
            tooltip.innerHTML = `
                <h3>${tech.name}</h3>
                <p><strong>Cost:</strong> ${tech.cost} Science</p>
                ${tech.prereqs.length > 0 ? `<p><strong>Prerequisites:</strong> ${prereqNames}</p>` : ''}
                ${unlocksList}
                <p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to toggle research</p>
            `;
            
            // Position tooltip accounting for scroll and viewport
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Try to position to the right of the item, but adjust if it would go off-screen
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // If tooltip would go off the right edge, position it to the left
            if (left + 300 > window.innerWidth) { // Assuming tooltip is ~300px wide
                left = rect.left + scrollLeft - 310;
            }
            
            // If tooltip would go off the bottom, adjust upward
            if (top + 200 > window.innerHeight + scrollTop) { // Assuming tooltip is ~200px tall
                top = rect.bottom + scrollTop - 200;
            }
            
            tooltip.style.left = Math.max(10, left) + 'px'; // Don't go off left edge
            tooltip.style.top = Math.max(10, top) + 'px'; // Don't go off top edge
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }

        function showBonusTooltip(event, bonusTech) {
            const tooltip = document.getElementById('tooltip');
            
            // Find parent tech
            const parentTech = techData.techs.find(t => t.id === bonusTech.parent);
            const parentName = parentTech ? parentTech.name : bonusTech.parent;
            
            // Determine the appropriate emoji based on bonus content
            let bonusEmoji = 'üíé';
            if (bonusTech.bonus.includes('Stone') || bonusTech.bonus.includes('Iron') || bonusTech.bonus.includes('Food')) {
                bonusEmoji = 'üì¶'; // Resources
            } else if (bonusTech.bonus.includes('Worker') || bonusTech.bonus.includes('Science')) {
                bonusEmoji = 'üî¨'; // Science/Workers
            } else if (bonusTech.bonus.includes('Courtier') || bonusTech.bonus.includes('General') || 
                      bonusTech.bonus.includes('Governor') || bonusTech.bonus.includes('Spymaster')) {
                bonusEmoji = 'üë§'; // Courtiers
            } else if (bonusTech.bonus.includes('+1') || bonusTech.bonus.includes('+2')) {
                bonusEmoji = '‚öîÔ∏è'; // Units
            }
            
            tooltip.innerHTML = `
                <h3>${bonusTech.name}</h3>
                <p><strong>Cost:</strong> ${bonusTech.cost} üß™</p>
                <p><strong>Parent Tech:</strong> ${parentName}</p>
                <div class="unlocks-list">
                    <h4>Bonus:</h4>
                    <ul><li>${bonusEmoji} ${bonusTech.bonus}</li></ul>
                </div>
            `;
            
            // Position tooltip accounting for scroll and viewport
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Try to position to the right of the item, but adjust if it would go off-screen
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // If tooltip would go off the right edge, position it to the left
            if (left + 300 > window.innerWidth) { // Assuming tooltip is ~300px wide
                left = rect.left + scrollLeft - 310;
            }
            
            // If tooltip would go off the bottom, adjust upward
            if (top + 200 > window.innerHeight + scrollTop) { // Assuming tooltip is ~200px tall
                top = rect.bottom + scrollTop - 200;
            }
            
            tooltip.style.left = Math.max(10, left) + 'px'; // Don't go off left edge
            tooltip.style.top = Math.max(10, top) + 'px'; // Don't go off top edge
            tooltip.classList.add('show');
        }

        function shareBuild() {
            if (researchedTechs.length === 0 && !selectedNation) {
                alert('No technologies researched or nation selected to share!');
                return;
            }
            
            const urlParts = [];
            
            // Add nation if selected (using numeric index)
            if (selectedNation) {
                const nationIndex = nationLookup.findIndex(n => n === selectedNation);
                if (nationIndex !== -1) {
                    urlParts.push(`n=${nationIndex}`);
                }
            }
            
            // Add techs if any are researched
            if (researchedTechs.length > 0) {
                const techNumbers = researchedTechs.map(techId => {
                    return techData.techs.findIndex(t => t.id === techId);
                }).filter(index => index !== -1);
                urlParts.push(`t=${techNumbers.join(',')}`);
            }
            
            // Add bonus techs if any are researched
            if (researchedBonusTechs.length > 0) {
                const bonusNumbers = researchedBonusTechs.map(bonusTechId => {
                    return techData.bonusTechs.findIndex(t => t.id === bonusTechId);
                }).filter(index => index !== -1);
                urlParts.push(`b=${bonusNumbers.join(',')}`);
            }
            
            const url = urlParts.length > 0 
                ? `https://alcaras.github.io/owtt/?${urlParts.join('&')}`
                : 'https://alcaras.github.io/owtt/';
            
            // Copy to clipboard and show feedback
            const shareButton = document.querySelector('.share-button');
            const originalText = shareButton.textContent;
            
            navigator.clipboard.writeText(url).then(() => {
                // Show "Copied!" feedback
                shareButton.textContent = 'Copied!';
                shareButton.style.background = 'linear-gradient(135deg, #4a8a4a, #6ab36a)';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    shareButton.textContent = originalText;
                    shareButton.style.background = 'linear-gradient(135deg, #8b6914, #b4a037)';
                }, 2000);
            }).catch(() => {
                // Fallback if clipboard API fails
                shareButton.textContent = 'Copy Failed';
                setTimeout(() => {
                    shareButton.textContent = originalText;
                }, 2000);
            });
        }

        function loadFromUrl() {
            const params = new URLSearchParams(window.location.search);
            
            // Load nation first (new format: n=index, old format: nation=NAME for backward compatibility)
            let nationParam = params.get('n');
            if (nationParam !== null) {
                const nationIndex = parseInt(nationParam);
                if (nationIndex >= 0 && nationIndex < nationLookup.length) {
                    selectedNation = nationLookup[nationIndex];
                }
            } else {
                // Backward compatibility with old format
                nationParam = params.get('nation');
                if (nationParam) {
                    selectedNation = nationParam;
                }
            }
            
            if (selectedNation) {
                const select = document.getElementById('nationSelect');
                select.value = selectedNation;
                
                // Add starting techs
                if (nationData.startingTechs[selectedNation]) {
                    const startingTechs = nationData.startingTechs[selectedNation];
                    startingTechs.forEach(techId => {
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    });
                }
            }
            
            // Load main techs (new format: t=1,2,3, old format: techs=1,2,3 for backward compatibility)
            let techsParam = params.get('t') || params.get('techs');
            if (techsParam) {
                const techNumbers = techsParam.split(',').map(n => parseInt(n)).filter(n => !isNaN(n));
                
                // Convert numbers back to tech IDs and validate
                techNumbers.forEach(techIndex => {
                    if (techIndex >= 0 && techIndex < techData.techs.length) {
                        const techId = techData.techs[techIndex].id;
                        const tech = techData.techs[techIndex];
                        
                        // Add prerequisites first
                        const prereqsToAdd = getAllPrerequisites(techId);
                        prereqsToAdd.forEach(prereqId => {
                            if (!researchedTechs.includes(prereqId)) {
                                researchedTechs.push(prereqId);
                                researchOrder.push(Date.now());
                            }
                        });
                        
                        // Add the tech itself
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    }
                });
            }
            
            // Load bonus techs (new format: b=1,2,3, old format: bonus=1,2,3 for backward compatibility)
            let bonusParam = params.get('b') || params.get('bonus');
            if (bonusParam) {
                const bonusNumbers = bonusParam.split(',').map(n => parseInt(n)).filter(n => !isNaN(n));
                
                bonusNumbers.forEach(bonusIndex => {
                    if (bonusIndex >= 0 && bonusIndex < techData.bonusTechs.length) {
                        const bonusTechId = techData.bonusTechs[bonusIndex].id;
                        if (!researchedBonusTechs.includes(bonusTechId)) {
                            researchedBonusTechs.push(bonusTechId);
                        }
                    }
                });
            }
            
            // Update displays
            initializeBonusTechs();
            updateOrderList();
        }

        function clearBuild() {
            const clearButton = document.querySelector('.clear-button');
            if (clearButton.classList.contains('disabled')) {
                return; // Don't clear if disabled
            }
            
            // Preserve the selected nation
            const currentNation = selectedNation;
            
            researchedTechs = [];
            researchOrder = [];
            researchedBonusTechs = [];
            
            // If a nation is selected, keep it selected and add its starting techs back
            if (currentNation) {
                selectedNation = currentNation;
                
                // Add starting techs for the selected nation
                if (nationData.startingTechs[currentNation]) {
                    const startingTechs = nationData.startingTechs[currentNation];
                    startingTechs.forEach(techId => {
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    });
                }
                
                // Keep nation selector value
                const select = document.getElementById('nationSelect');
                select.value = currentNation;
            } else {
                // Only reset nation if none was selected
                selectedNation = '';
                const select = document.getElementById('nationSelect');
                select.value = '';
            }
            
            initializeBonusTechs();
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after clearing
            
            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        function selectNation() {
            const select = document.getElementById('nationSelect');
            selectedNation = select.value;
            
            // Clear current research when changing nations
            researchedTechs = [];
            researchOrder = [];
            researchedBonusTechs = [];
            
            // Add starting techs if a nation is selected
            if (selectedNation && nationData.startingTechs[selectedNation]) {
                const startingTechs = nationData.startingTechs[selectedNation];
                startingTechs.forEach(techId => {
                    if (!researchedTechs.includes(techId)) {
                        researchedTechs.push(techId);
                        researchOrder.push(Date.now());
                    }
                });
            }
            
            // Update the bonus tech display to show/hide nation-specific bonuses
            initializeBonusTechs();
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after nation change
        }

        // Simulation functions
        function openSimulationPanel() {
            if (researchedTechs.length === 0) {
                alert('Please select some technologies to research first!');
                return;
            }
            
            document.getElementById('simulationOverlay').style.display = 'block';
            document.getElementById('simulationPanel').style.display = 'block';
            document.getElementById('simulationResults').style.display = 'none';
        }

        function closeSimulationPanel() {
            document.getElementById('simulationOverlay').style.display = 'none';
            document.getElementById('simulationPanel').style.display = 'none';
        }

        function runSimulation() {
            // Show loading state
            const runButton = document.querySelector('.sim-run-button');
            const originalText = runButton.textContent;
            runButton.textContent = 'Running...';
            runButton.disabled = true;
            
            const loadingElement = document.getElementById('simulationLoading');
            const tableElement = document.getElementById('comparisonTable');
            if (loadingElement) loadingElement.style.display = 'block';
            if (tableElement) tableElement.style.display = 'none';
            
            // Run simulation after short delay to show loading state
            setTimeout(() => {
                const variants = [
                    { scholar: false, oracle: false, name: "Base" },
                    { scholar: true, oracle: false, name: "Scholar Only" },
                    { scholar: false, oracle: true, name: "Oracle Only" },
                    { scholar: true, oracle: true, name: "Scholar + Oracle" }
                ];
                
                const allResults = [];
                
                for (const variant of variants) {
                    console.log(`üöÄ Starting variant: ${variant.name} (Scholar=${variant.scholar}, Oracle=${variant.oracle})`);
                    const results = simulateResearchPath(variant.scholar, variant.oracle, 1000);
                    console.log(`‚úÖ Completed variant: ${variant.name}`, results);
                    allResults.push({
                        name: variant.name,
                        results: results
                    });
                }
                
                console.log('All simulation results:', allResults);
                displayComparisonResults(allResults);
                
                const loading = document.getElementById('simulationLoading');
                const panel = document.getElementById('simulationPanel');
                const overlay = document.getElementById('simulationOverlay');
                
                console.log('Elements found:');
                console.log('- loading element:', !!loading);
                console.log('- simulation panel:', !!panel);
                console.log('- simulation overlay:', !!overlay);
                
                if (panel) {
                    console.log('Panel display style:', panel.style.display);
                    console.log('Panel visibility:', panel.style.visibility);
                    console.log('Panel dimensions:', panel.offsetWidth, 'x', panel.offsetHeight);
                }
                
                if (loading) loading.style.display = 'none';
                console.log('Results should now be visible using div layout');
                
                runButton.textContent = originalText;
                runButton.disabled = false;
            }, 100);
        }

        function simulateResearchPath(hasScholar, hasOracle, numSimulations) {
            const results = [];
            
            // Build research path from current selections, excluding starting techs
            const researchPath = [
                ...researchedTechs.filter(techId => !isStartingTech(techId)),
                ...researchedBonusTechs
            ];
            
            // Debug: Calculate expected cost and compare to UI
            let expectedCost = 0;
            researchedTechs.forEach(techId => {
                if (!isStartingTech(techId)) {
                    const tech = techData.techs.find(t => t.id === techId);
                    if (tech) expectedCost += tech.cost;
                }
            });
            researchedBonusTechs.forEach(bonusId => {
                const bonus = techData.bonusTechs.find(t => t.id === bonusId);
                if (bonus) expectedCost += bonus.cost;
            });
            
            console.log(`üîç DEBUG: Expected total cost: ${expectedCost}`);
            console.log(`üîç DEBUG: Research path: ${researchPath.length} techs`);
            console.log(`üîç DEBUG: Main techs (non-starting): ${researchedTechs.filter(techId => !isStartingTech(techId)).length}`);
            console.log(`üîç DEBUG: Bonus techs: ${researchedBonusTechs.length}`);
            
            // Enable detailed debugging for first run only
            window.debugSimulation = true;
            
            for (let sim = 0; sim < numSimulations; sim++) {
                if (sim === 1) {
                    window.debugSimulation = false; // Turn off debugging after first run
                }
                const result = simulateSingleRun(researchPath, hasScholar, hasOracle);
                if (result.failed) {
                    results.push({ failed: true, reason: result.reason });
                } else {
                    results.push(result.cost);
                }
            }
            
            // Separate successful and failed runs
            const successfulRuns = results.filter(r => typeof r === 'number');
            const failedRuns = results.filter(r => typeof r === 'object' && r.failed);
            
            if (successfulRuns.length === 0) {
                return { 
                    min: 0, max: 0, avg: 0, stdDev: 0, 
                    successRate: 0, 
                    failureReasons: failedRuns.reduce((acc, fail) => {
                        acc[fail.reason] = (acc[fail.reason] || 0) + 1;
                        return acc;
                    }, {}),
                    results: results 
                };
            }
            
            // Calculate statistics for successful runs
            const sortedResults = successfulRuns.sort((a, b) => a - b);
            const min = sortedResults[0];
            const max = sortedResults[sortedResults.length - 1];
            const avg = successfulRuns.reduce((sum, cost) => sum + cost, 0) / successfulRuns.length;
            
            // Calculate standard deviation
            const variance = successfulRuns.reduce((sum, cost) => sum + Math.pow(cost - avg, 2), 0) / successfulRuns.length;
            const stdDev = Math.sqrt(variance);
            
            const successRate = successfulRuns.length / results.length;
            const failureReasons = failedRuns.reduce((acc, fail) => {
                acc[fail.reason] = (acc[fail.reason] || 0) + 1;
                return acc;
            }, {});
            
            return { min, max, avg, stdDev, successRate, failureReasons, results };
        }

        function isStartingTech(techId) {
            return selectedNation && 
                   nationData.startingTechs[selectedNation] && 
                   nationData.startingTechs[selectedNation].includes(techId);
        }

        function simulateSingleRun(researchPath, hasScholar, hasOracle) {
            let completedTechs = new Set();
            let removedBonusCards = new Set(); // Track permanently removed bonus cards
            let totalCost = 0;
            let turnCount = 0;
            
            if (window.debugSimulation) {
                console.log(`üé≤ Starting simulation: Scholar=${hasScholar}, Oracle=${hasOracle}`);
                console.log(`üéØ Target techs: ${researchPath.map(id => {
                    const mainTech = techData.techs.find(t => t.id === id);
                    const bonusTech = techData.bonusTechs.find(t => t.id === id);
                    return (mainTech || bonusTech)?.name || id;
                }).join(', ')}`);
            }
            
            // Add starting techs as already completed
            if (selectedNation && nationData.startingTechs[selectedNation]) {
                nationData.startingTechs[selectedNation].forEach(techId => {
                    completedTechs.add(techId);
                });
                if (window.debugSimulation) {
                    console.log(`üèõÔ∏è Starting techs: ${Array.from(completedTechs).map(id => {
                        const tech = techData.techs.find(t => t.id === id);
                        return tech?.name || id;
                    }).join(', ')}`);
                }
            }
            
            // Separate main techs and bonus cards in research path
            const targetMainTechs = researchPath.filter(id => techData.techs.some(t => t.id === id));
            const targetBonusCards = researchPath.filter(id => techData.bonusTechs.some(t => t.id === id));
            const targetTechSet = new Set(researchPath);
            
            if (window.debugSimulation && targetBonusCards.length > 0) {
                console.log(`üéÅ Target bonus cards: ${targetBonusCards.map(id => {
                    const bonus = techData.bonusTechs.find(t => t.id === id);
                    return bonus?.name || id;
                }).join(', ')}`);
            }
            
            // Keep researching until all target techs are completed
            while (!isSubset(targetTechSet, completedTechs) && turnCount < 500) {
                turnCount++;
                
                // Check if any required bonus cards have been permanently removed
                const missedBonusCards = targetBonusCards.filter(id => removedBonusCards.has(id));
                if (missedBonusCards.length > 0) {
                    if (window.debugSimulation) {
                        console.warn(`üíî Failed: Required bonus cards permanently lost: ${missedBonusCards.map(id => {
                            const bonus = techData.bonusTechs.find(t => t.id === id);
                            return bonus?.name || id;
                        }).join(', ')}`);
                    }
                    return { cost: -1, failed: true, reason: 'missed_bonus_cards', missedCards: missedBonusCards };
                }
                
                // Get currently available techs (prerequisites met, not completed, not removed)
                const availableTechs = getAvailableTechs(completedTechs, removedBonusCards);
                const drawPile = [...availableTechs];
                const discardPile = [];
                shuffleArray(drawPile);
                
                if (window.debugSimulation && turnCount === 1) {
                    const mainCount = availableTechs.filter(t => !t.isBonus).length;
                    const bonusCount = availableTechs.filter(t => t.isBonus).length;
                    console.log(`üìö Available techs: ${mainCount} main + ${bonusCount} bonus = ${availableTechs.length} total`);
                }
                
                // Research one tech this turn
                const result = researchOneTurn(targetTechSet, drawPile, discardPile, completedTechs, hasScholar, hasOracle, turnCount, removedBonusCards);
                if (result.cost >= 0) {
                    totalCost += result.cost;
                    if (result.removedBonusCards) {
                        result.removedBonusCards.forEach(id => removedBonusCards.add(id));
                    }
                } else {
                    if (window.debugSimulation) {
                        console.warn('‚ö†Ô∏è No progress made this turn, ending simulation');
                    }
                    break;
                }
            }
            
            // Check final success/failure
            const success = isSubset(targetTechSet, completedTechs);
            
            if (window.debugSimulation) {
                console.log(`üèÅ Simulation ${success ? 'SUCCESS' : 'FAILED'} after ${turnCount} turns, total cost: ${totalCost}`);
                if (!success) {
                    const remaining = Array.from(targetTechSet).filter(id => !completedTechs.has(id));
                    console.log(`‚ùå Missing techs: ${remaining.join(', ')}`);
                }
            }
            
            return success ? { cost: totalCost, failed: false } : { cost: -1, failed: true, reason: 'incomplete', totalCost };
        }

        function isSubset(subset, superset) {
            for (const item of subset) {
                if (!superset.has(item)) {
                    return false;
                }
            }
            return true;
        }

        function getAvailableTechs(completedTechs, removedBonusCards = new Set()) {
            const availableMainTechs = techData.techs.filter(tech => {
                // Skip if already completed or is a starting tech
                if (completedTechs.has(tech.id) || isStartingTech(tech.id)) {
                    return false;
                }
                
                // Check if all prerequisites are met
                return (tech.prereqs || []).every(prereqId => completedTechs.has(prereqId));
            });
            
            const availableBonusCards = techData.bonusTechs.filter(bonus => {
                // Skip if already completed or permanently removed
                if (completedTechs.has(bonus.id) || removedBonusCards.has(bonus.id)) {
                    return false;
                }
                
                // Filter by nation - same logic as initializeBonusTechs
                if (bonus.nation && (!selectedNation || bonus.nation !== selectedNation)) {
                    return false;
                }
                
                // Check if prerequisite main tech is completed
                return (bonus.prereqs || []).every(prereqId => completedTechs.has(prereqId));
            });
            
            // Mark bonus cards so we can identify them later
            availableBonusCards.forEach(bonus => {
                bonus.isBonus = true;
            });
            
            return [...availableMainTechs, ...availableBonusCards];
        }

        function researchOneTurn(targetTechSet, drawPile, discardPile, completedTechs, hasScholar, hasOracle, turnCount, removedBonusCards) {
            if (window.debugSimulation) {
                console.log(`\n--- Turn ${turnCount} ---`);
                console.log(`üìä Available techs: ${drawPile.length}, Completed: ${completedTechs.size}`);
                console.log(`üîÆ Oracle: ${hasOracle ? 'YES (+1 card)' : 'NO'}, üìú Scholar: ${hasScholar ? 'YES (redraw available)' : 'NO'}`);
            }
            
            // Draw hand from available techs
            const handSize = hasOracle ? 5 : 4;
            const hand = drawHand(drawPile, discardPile, handSize);
            
            if (hand.length === 0) {
                if (window.debugSimulation) {
                    console.warn('‚ö†Ô∏è No techs available to draw');
                }
                return { cost: 0 };
            }
            
            if (window.debugSimulation) {
                console.log(`‚úã Hand (${hand.length}/${handSize}): ${hand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
            }
            
            // Look for target techs in hand
            const targetsInHand = hand.filter(tech => targetTechSet.has(tech.id));
            const bonusTargetsInHand = targetsInHand.filter(tech => tech.isBonus);
            
            let bestChoice = null;
            
            if (targetsInHand.length > 0) {
                // Handle multiple bonus cards dilemma
                if (bonusTargetsInHand.length > 1) {
                    if (window.debugSimulation) {
                        console.warn(`‚ö†Ô∏è Multiple target bonus cards in hand! Can only choose one:`);
                        bonusTargetsInHand.forEach(bonus => {
                            console.warn(`   - ${bonus.name}`);
                        });
                    }
                    // Choose the most expensive bonus card (arbitrary strategy)
                    bestChoice = bonusTargetsInHand.reduce((mostExpensive, bonus) => 
                        bonus.cost > mostExpensive.cost ? bonus : mostExpensive
                    );
                    if (window.debugSimulation) {
                        console.log(`üéØ Choosing most expensive bonus: ${bestChoice.name} (${bestChoice.cost} üß™)`);
                    }
                } else {
                    // Single target or main tech - select it
                    bestChoice = targetsInHand[0];
                    if (window.debugSimulation) {
                        const techType = bestChoice.isBonus ? 'üéÅ bonus card' : 'üî¨ main tech';
                        console.log(`‚úÖ Found target ${techType}! Selecting: ${bestChoice.name}`);
                    }
                }
            } else {
                // No target tech in hand - consider Scholar redraw
                if (hasScholar && shouldRedrawForTargets(hand, targetTechSet, drawPile, discardPile)) {
                    if (window.debugSimulation) {
                        console.log(`üìú Scholar redraw: Looking for target techs...`);
                    }
                    
                    // Discard current hand and redraw
                    discardPile.push(...hand);
                    const newHand = drawHand(drawPile, discardPile, handSize);
                    const newTargetInHand = newHand.find(tech => targetTechSet.has(tech.id));
                    
                    if (window.debugSimulation) {
                        console.log(`‚úã New hand (${newHand.length}): ${newHand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
                    }
                    
                    if (newTargetInHand) {
                        bestChoice = newTargetInHand;
                        if (window.debugSimulation) {
                            console.log(`‚úÖ Found target in redraw! Selecting: ${newTargetInHand.name}`);
                        }
                    } else if (newHand.length > 0) {
                        // Pick cheapest from new hand
                        bestChoice = newHand.reduce((cheapest, tech) => 
                            tech.cost < cheapest.cost ? tech : cheapest
                        );
                        if (window.debugSimulation) {
                            console.log(`üí∞ No target in redraw, picking cheapest: ${bestChoice.name} (${bestChoice.cost} üß™)`);
                        }
                    }
                } else {
                    // No redraw - pick cheapest to advance deck
                    bestChoice = hand.reduce((cheapest, tech) => 
                        tech.cost < cheapest.cost ? tech : cheapest
                    );
                    if (window.debugSimulation) {
                        console.log(`üí∞ No target, picking cheapest: ${bestChoice.name} (${bestChoice.cost} üß™)`);
                    }
                }
            }
            
            if (bestChoice) {
                completedTechs.add(bestChoice.id);
                
                // Handle discarded cards - bonus cards are permanently removed
                const removedThisTurn = [];
                hand.forEach(tech => {
                    if (tech.id !== bestChoice.id && tech.isBonus) {
                        removedBonusCards.add(tech.id);
                        removedThisTurn.push(tech.id);
                        if (window.debugSimulation) {
                            console.log(`üíî Bonus card permanently removed: ${tech.name}`);
                        }
                    } else if (tech.id !== bestChoice.id) {
                        // Main techs go to discard pile (handled by drawHand reshuffling)
                        discardPile.push(tech);
                    }
                });
                
                if (window.debugSimulation) {
                    const techType = bestChoice.isBonus ? 'üéÅ BONUS' : 'üî¨ MAIN';
                    console.log(`${techType} Researched: ${bestChoice.name} - now completed!`);
                }
                
                return { 
                    cost: bestChoice.cost, 
                    removedBonusCards: removedThisTurn.length > 0 ? removedThisTurn : null 
                };
            }
            
            return { cost: 0 };
        }

        function drawHand(drawPile, discardPile, handSize) {
            const hand = [];
            
            for (let i = 0; i < handSize; i++) {
                // Reshuffle if draw pile is empty
                if (drawPile.length === 0 && discardPile.length > 0) {
                    if (window.debugSimulation) {
                        console.log(`üîÑ Reshuffling: Moving ${discardPile.length} cards from discard to draw pile`);
                    }
                    drawPile.push(...discardPile);
                    discardPile.length = 0;
                    shuffleArray(drawPile);
                    if (window.debugSimulation) {
                        console.log(`üÉè Draw pile shuffled, now has ${drawPile.length} cards`);
                    }
                }
                
                // Draw from pile if available
                if (drawPile.length > 0) {
                    hand.push(drawPile.pop());
                }
            }
            
            return hand;
        }

        function shouldRedrawForTargets(hand, targetTechSet, drawPile, discardPile) {
            // Smart Scholar redraw logic based on expected value
            const allAvailableCards = [...drawPile, ...discardPile];
            const targetStillAvailable = allAvailableCards.some(tech => targetTechSet.has(tech.id));
            
            if (!targetStillAvailable) return false;
            
            // Calculate current hand stats
            const avgHandCost = hand.reduce((sum, tech) => sum + tech.cost, 0) / hand.length;
            const cheapestInHand = Math.min(...hand.map(tech => tech.cost));
            
            // Calculate expected stats of available deck
            const avgDeckCost = allAvailableCards.reduce((sum, tech) => sum + tech.cost, 0) / allAvailableCards.length;
            const targetProbability = allAvailableCards.filter(tech => targetTechSet.has(tech.id)).length / allAvailableCards.length;
            
            // Expected value calculation:
            // If we find target: we get target tech (good!)
            // If we don't find target: we get average deck cost
            const expectedRedrawCost = (targetProbability * 0) + ((1 - targetProbability) * avgDeckCost);
            
            // Redraw if:
            // 1. Current hand is worse than expected redraw outcome
            // 2. Target probability is reasonable (> 10%)
            // 3. Current hand is significantly above deck average (> 1.2x)
            const handVsDeckRatio = avgHandCost / avgDeckCost;
            const shouldRedraw = (cheapestInHand > expectedRedrawCost) && 
                               (targetProbability > 0.10) && 
                               (handVsDeckRatio > 1.2);
            
            if (window.debugSimulation) {
                console.log(`üìú Scholar analysis: handAvg=${Math.round(avgHandCost)}, deckAvg=${Math.round(avgDeckCost)}, ratio=${handVsDeckRatio.toFixed(2)}, targetProb=${Math.round(targetProbability*100)}%, redraw=${shouldRedraw ? 'YES' : 'NO'}`);
            }
            
            return shouldRedraw;
        }


        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function displayComparisonResults(allResults) {
            console.log('displayComparisonResults called with:', allResults);
            
            // Try a different approach - replace the entire table with a simple div
            const container = document.getElementById('simulationResults');
            if (!container) {
                console.error('Could not find simulationResults container');
                console.log('Available elements with IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id));
                return;
            }
            
            console.log('Container found:', container);
            console.log('Container current content:', container.innerHTML);
            console.log('Container parent:', container.parentElement?.tagName, container.parentElement?.id);
            
            // Find min/max values for scaling
            const allMins = allResults.map(r => r.results.min);
            const allMaxs = allResults.map(r => r.results.max);
            const allAvgs = allResults.map(r => r.results.avg);
            const globalMin = Math.min(...allMins);
            const globalMax = Math.max(...allMaxs);
            const range = globalMax - globalMin;
            
            let html = `
                <div style="color: #d4af37; font-size: 1.1em; margin-bottom: 15px; text-align: center;">
                    üìä Research Cost Comparison (1000 runs each)
                </div>
                <div style="background: rgba(139, 105, 20, 0.15); padding: 15px; border-radius: 8px; border: 1px solid #8b6914;">
            `;
            
            for (const variant of allResults) {
                console.log(`Processing variant: ${variant.name}`, variant.results);
                const results = variant.results;
                const rangeMin = Math.round(results.avg - results.stdDev);
                const rangeMax = Math.round(results.avg + results.stdDev);
                
                // Calculate bar widths as percentages
                const minPercent = ((results.min - globalMin) / range) * 100;
                const maxPercent = ((results.max - globalMin) / range) * 100;
                const avgPercent = ((results.avg - globalMin) / range) * 100;
                const stdDevLeftPercent = ((rangeMin - globalMin) / range) * 100;
                const stdDevRightPercent = ((rangeMax - globalMin) / range) * 100;
                
                html += `
                    <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                        <div style="color: #d4af37; font-weight: bold; margin-bottom: 4px; font-size: 0.95em; display: flex; justify-content: space-between;">
                            <span>${variant.name}</span>
                            <span style="color: ${results.successRate >= 0.95 ? 'var(--primary-green)' : results.successRate >= 0.8 ? 'var(--primary-gold)' : 'var(--light-red)'};">
                                ${Math.round(results.successRate * 100)}% success
                            </span>
                        </div>
                        
                        <!-- Bar chart container -->
                        <div style="position: relative; height: 20px; background: rgba(0,0,0,0.5); border-radius: 10px; margin: 6px 0; border: 1px solid #444;">
                            <!-- Min-Max range bar (light gray) -->
                            <div style="position: absolute; top: 8px; left: ${minPercent}%; width: ${maxPercent - minPercent}%; height: 8px; background: rgba(128,128,128,0.4); border-radius: 4px;"></div>
                            
                            <!-- StdDev range bar (gold) -->
                            <div style="position: absolute; top: 8px; left: ${stdDevLeftPercent}%; width: ${stdDevRightPercent - stdDevLeftPercent}%; height: 14px; background: var(--primary-gold); opacity: 0.6; border-radius: 7px;"></div>
                            
                            <!-- Average line (blue) -->
                            <div style="position: absolute; top: 5px; left: ${avgPercent}%; width: 3px; height: 20px; background: var(--light-blue); border-radius: 1px;"></div>
                            
                            <!-- Min marker (green) -->
                            <div style="position: absolute; top: 3px; left: ${minPercent}%; width: 2px; height: 24px; background: var(--primary-green);"></div>
                            
                            <!-- Max marker (red) -->
                            <div style="position: absolute; top: 3px; left: ${maxPercent}%; width: 2px; height: 24px; background: var(--light-red);"></div>
                        </div>
                        
                        <!-- Legend -->
                        <div style="color: var(--text-light); font-size: 0.85em; display: flex; justify-content: space-between; margin-top: 5px;">
                            <span>Min: <span style="color: var(--primary-green);">${results.min}</span></span>
                            <span>Avg: <span style="color: var(--light-blue);">${Math.round(results.avg)}</span></span>
                            <span>Max: <span style="color: var(--light-red);">${results.max}</span></span>
                            <span>¬±œÉ: <span style="color: var(--primary-gold);">${Math.round(results.stdDev)}</span></span>
                        </div>
                        
                    </div>
                `;
            }
            
            html += `
                <div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.75em; color: var(--text-muted); text-align: center;">
                    <strong>Legend:</strong> 
                    <span style="color: var(--primary-green);">Green</span> = Min | 
                    <span style="color: var(--light-blue);">Blue</span> = Average | 
                    <span style="color: var(--light-red);">Red</span> = Max | 
                    <span style="color: var(--primary-gold);">Gold bar</span> = ¬±1 Standard Deviation
                </div>
            `;
            container.innerHTML = html;
            
            // CRITICAL: Make sure the container itself is visible!
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.opacity = '1';
            
            console.log('Results displayed using div layout instead of table');
            console.log('Container display set to:', container.style.display);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            drawConnections();
        });

        // Initialize the tech tree when page loads
        window.addEventListener('load', initializeTechTree);
    </script>
</body>
</html>