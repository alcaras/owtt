<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Old World Tech Tree</title>
    <script src="https://cdn.jsdelivr.net/npm/leader-line@1.0.7/leader-line.min.js"></script>
    <link rel="stylesheet" href="styles.css">

</head>
<body>
    <div class="main-container">
        <div class="tech-tree-wrapper">
            <div class="tech-cost-headers">
                <div class="tech-cost-header">80 🧪</div>
                <div class="tech-cost-header">120 🧪</div>
                <div class="tech-cost-header">200 🧪</div>
                <div class="tech-cost-header">400 🧪</div>
                <div class="tech-cost-header">600 🧪</div>
                <div class="tech-cost-header">1000 🧪</div>
                <div class="tech-cost-header">1600 🧪</div>
                <div class="tech-cost-header">2000 🧪</div>
            </div>
            <div class="tech-tree" id="techTree"></div>
            
            <div class="bonus-tech-section">
                <h3>💎 Bonus Cards</h3>
                <div class="bonus-tech-grid" id="bonusTechGrid"></div>
            </div>
        </div>
    </div>

    <div class="sidebar">
        <div class="share-section">
            <button class="share-button" onclick="shareBuild()">Share Build</button>
        </div>
        
        <div class="nation-section">
            <h2>Nation</h2>
            <select class="nation-select" id="nationSelect" onchange="selectNation()">
                <option value="">No Nation</option>
                <option value="NATION_AKSUM">Aksum</option>
                <option value="NATION_ASSYRIA">Assyria</option>
                <option value="NATION_BABYLONIA">Babylonia</option>
                <option value="NATION_CARTHAGE">Carthage</option>
                <option value="NATION_EGYPT">Egypt</option>
                <option value="NATION_GREECE">Greece</option>
                <option value="NATION_HITTITE">Hittites</option>
                <option value="NATION_KUSH">Kush</option>
                <option value="NATION_PERSIA">Persia</option>
                <option value="NATION_ROME">Rome</option>
            </select>
        </div>
        
        <h2>Research Order</h2>
        <button class="simulate-button" onclick="openSimulationPanel()">🎲 Simulate Research</button>
        <div class="total-cost" id="totalCost">Total Cost: 0</div>
        <div class="total-laws" id="totalLaws">Laws Available: 0</div>
        <div class="tech-order-list" id="techOrderList"></div>
        
        <button class="clear-button" onclick="clearBuild()">Clear All</button>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Simulation Panel -->
    <div class="simulation-overlay" id="simulationOverlay" onclick="closeSimulationPanel()"></div>
    <div class="simulation-panel" id="simulationPanel">
        <button onclick="closeSimulationPanel()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; color: var(--primary-gold); font-size: 24px; cursor: pointer; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background 0.2s;" onmouseover="this.style.background='rgba(212, 175, 55, 0.2)'" onmouseout="this.style.background='none'">×</button>
        
        <h3>🎲 Research Simulation Comparison</h3>
        <p style="color: #f4e4c1; margin-bottom: 15px; text-align: center; font-size: 0.9em;">
            Running 1000 simulations for each Scholar/Oracle combination to compare variance in research costs.
        </p>
        
        <div class="simulation-buttons" style="margin-bottom: 15px; text-align: center;">
            <button class="sim-run-button" onclick="runSimulation()">Run All Simulations</button>
        </div>
        
        <div class="simulation-comparison" id="simulationResults">
            <div class="comparison-loading" id="simulationLoading" style="display: none;">
                🔄 Running simulations... This may take a few moments.
            </div>
            <table class="comparison-table" id="comparisonTable">
                <thead>
                    <tr>
                        <th>Configuration</th>
                        <th>Min Cost</th>
                        <th>Max Cost</th>
                        <th>Average Cost</th>
                        <th>Std Dev</th>
                        <th>Expected Range</th>
                    </tr>
                </thead>
                <tbody id="comparisonResults">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Complete tech tree data from game files with correct prerequisites and unlocks
        const techData = {
            techs: [
                { id: "TECH_IRONWORKING", name: "Ironworking", cost: 80, column: 0, row: 2, prereqs: [], unlocks: { units: ["Warrior"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_STONECUTTING", name: "Stonecutting", cost: 80, column: 0, row: 5, prereqs: [], unlocks: { units: [], improvements: ["Fort", "Quarry"], laws: [], projects: [] } },
                { id: "TECH_TRAPPING", name: "Trapping", cost: 80, column: 0, row: 7, prereqs: [], unlocks: { units: ["Slinger"], improvements: ["Camp"], laws: [], projects: [] } },
                { id: "TECH_DIVINATION", name: "Divination", cost: 80, column: 0, row: 8, prereqs: [], unlocks: { units: [], improvements: ["Shrine"], laws: [], projects: [] } },
                { id: "TECH_ADMINISTRATION", name: "Administration", cost: 80, column: 0, row: 10, prereqs: [], unlocks: { units: [], improvements: ["Granary"], laws: [], projects: ["Treasury"] } },
                { id: "TECH_LABOR_FORCE", name: "Labor Force", cost: 120, column: 1, row: 1, prereqs: ["TECH_IRONWORKING"], unlocks: { units: [], improvements: [], laws: ["Slavery/Freedom"], projects: [] } },
                { id: "TECH_HUSBANDRY", name: "Husbandry", cost: 120, column: 1, row: 3, prereqs: ["TECH_IRONWORKING"], unlocks: { units: [], improvements: ["Pasture"], laws: [], projects: [] } },
                { id: "TECH_DRAMA", name: "Drama", cost: 120, column: 1, row: 4, prereqs: ["TECH_STONECUTTING"], unlocks: { units: [], improvements: ["Odeon"], laws: [], projects: [] } },
                { id: "TECH_POLIS", name: "Polis", cost: 120, column: 1, row: 5, prereqs: ["TECH_STONECUTTING"], unlocks: { units: [], improvements: ["Hamlet"], laws: [], projects: ["Walls"] } },
                { id: "TECH_MILITARY_DRILL", name: "Military Drill", cost: 120, column: 1, row: 7, prereqs: ["TECH_TRAPPING"], unlocks: { units: [], improvements: ["Barracks"], laws: [], projects: [] } },
                { id: "TECH_ARISTOCRACY", name: "Aristocracy", cost: 120, column: 1, row: 8, prereqs: ["TECH_DIVINATION"], unlocks: { units: [], improvements: ["Kushite Pyramids"], laws: ["Centralization/Vassalage"], projects: [] } },
                { id: "TECH_RHETORIC", name: "Rhetoric", cost: 120, column: 1, row: 10, prereqs: ["TECH_ADMINISTRATION"], unlocks: { units: [], improvements: [], laws: ["Epics/Exploration"], projects: ["Forum"] } },
                { id: "TECH_NAVIGATION", name: "Navigation", cost: 200, column: 2, row: 0, prereqs: ["TECH_LABOR_FORCE"], unlocks: { units: ["Bireme"], improvements: [], laws: ["Colonies/Serfdom"], projects: [] } },
                { id: "TECH_PHALANX", name: "Phalanx", cost: 200, column: 2, row: 2, prereqs: ["TECH_LABOR_FORCE"], unlocks: { units: ["Spearman"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_SPOKED_WHEEL", name: "Spoked Wheel", cost: 200, column: 2, row: 3, prereqs: ["TECH_HUSBANDRY"], unlocks: { units: ["Chariot"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_FORESTRY", name: "Forestry", cost: 200, column: 2, row: 5, prereqs: ["TECH_POLIS"], unlocks: { units: [], improvements: ["Lumbermill"], laws: [], projects: [] } },
                { id: "TECH_STEEL", name: "Steel", cost: 200, column: 2, row: 7, prereqs: ["TECH_IRONWORKING", "TECH_MILITARY_DRILL"], unlocks: { units: ["Axeman"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_SOVEREIGNTY", name: "Sovereignty", cost: 200, column: 2, row: 9, prereqs: ["TECH_ARISTOCRACY", "TECH_RHETORIC"], unlocks: { units: [], improvements: [], laws: ["Tyranny/Constitution"], projects: [] } },
                { id: "TECH_METAPHYSICS", name: "Metaphysics", cost: 200, column: 2, row: 10, prereqs: ["TECH_RHETORIC"], unlocks: { units: [], improvements: [], laws: [], projects: ["Archive"] } },
                { id: "TECH_COINAGE", name: "Coinage", cost: 400, column: 3, row: 0, prereqs: ["TECH_NAVIGATION"], unlocks: { units: [], improvements: ["Market"], laws: [], projects: [] } },
                { id: "TECH_CITIZENSHIP", name: "Citizenship", cost: 400, column: 3, row: 2, prereqs: ["TECH_PHALANX"], unlocks: { units: [], improvements: ["Courthouse"], laws: ["Divine Rule/Legal Code"], projects: [] } },
                { id: "TECH_PORTCULLIS", name: "Portcullis", cost: 400, column: 3, row: 3, prereqs: ["TECH_SPOKED_WHEEL"], unlocks: { units: [], improvements: [], laws: [], projects: ["Moat"] } },
                { id: "TECH_LAND_CONSOLIDATION", name: "Land Consolidation", cost: 400, column: 3, row: 5, prereqs: ["TECH_FORESTRY"], unlocks: { units: ["Camel Archer", "War Elephant"], improvements: ["Grove"], laws: [], projects: [] } },
                { id: "TECH_COMPOSITE_BOW", name: "Composite Bow", cost: 400, column: 3, row: 6, prereqs: ["TECH_MILITARY_DRILL"], unlocks: { units: ["Archer"], improvements: ["Range"], laws: [], projects: [] } },
                { id: "TECH_MONASTICISM", name: "Monasticism", cost: 400, column: 3, row: 8, prereqs: ["TECH_ARISTOCRACY"], unlocks: { units: [], improvements: ["Monastery"], laws: ["Monotheism/Polytheism"], projects: [] } },
                { id: "TECH_MACHINERY", name: "Machinery", cost: 400, column: 3, row: 9, prereqs: ["TECH_SOVEREIGNTY"], unlocks: { units: ["Onager"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_SCHOLARSHIP", name: "Scholarship", cost: 600, column: 4, row: 1, prereqs: ["TECH_CITIZENSHIP"], unlocks: { units: [], improvements: ["Library"], laws: [], projects: [] } },
                { id: "TECH_STIRRUPS", name: "Stirrups", cost: 600, column: 4, row: 3, prereqs: ["TECH_PORTCULLIS"], unlocks: { units: ["Horseman", "Horse Archer"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_ARCHITECTURE", name: "Architecture", cost: 400, column: 3, row: 4, prereqs: ["TECH_DRAMA"], unlocks: { units: [], improvements: ["Baths"], laws: ["Philosophy/Engineering"], projects: [] } },
                { id: "TECH_MANOR", name: "Manor", cost: 600, column: 4, row: 5, prereqs: ["TECH_LAND_CONSOLIDATION", "TECH_COMPOSITE_BOW"], unlocks: { units: ["Conscript"], improvements: [], laws: ["Professional Army/Volunteers"], projects: [] } },
                { id: "TECH_BATTLELINE", name: "Battleline", cost: 600, column: 4, row: 7, prereqs: ["TECH_PHALANX", "TECH_STEEL"], unlocks: { units: ["Maceman"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_DOCTRINE", name: "Doctrine", cost: 600, column: 4, row: 8, prereqs: ["TECH_MONASTICISM"], unlocks: { units: [], improvements: ["Temple"], laws: ["Tolerance/Orthodoxy"], projects: [] } },
                { id: "TECH_HYDRAULICS", name: "Hydraulics", cost: 600, column: 4, row: 9, prereqs: ["TECH_MACHINERY"], unlocks: { units: ["Ballista"], improvements: ["Mill"], laws: [], projects: [] } },
                { id: "TECH_CARTOGRAPHY", name: "Cartography", cost: 600, column: 4, row: 10, prereqs: ["TECH_NAVIGATION", "TECH_METAPHYSICS"], unlocks: { units: ["Trireme"], improvements: ["Harbor"], laws: [], projects: [] } },
                { id: "TECH_LATEEN_SAIL", name: "Lateen Sail", cost: 1000, column: 5, row: 0, prereqs: ["TECH_COINAGE", "TECH_CARTOGRAPHY"], unlocks: { units: ["Dromon"], improvements: [], laws: ["Autarky/Trade League"], projects: [] } },
                { id: "TECH_JURISPRUDENCE", name: "Jurisprudence", cost: 1000, column: 5, row: 1, prereqs: ["TECH_SCHOLARSHIP"], unlocks: { units: [], improvements: [], laws: ["Guilds/Elites"], projects: [] } },
                { id: "TECH_MARTIAL_CODE", name: "Martial Code", cost: 1000, column: 5, row: 2, prereqs: ["TECH_STIRRUPS", "TECH_CITIZENSHIP"], unlocks: { units: [], improvements: [], laws: ["Pilgrimage/Holy War"], projects: ["Towers"] } },
                { id: "TECH_VAULTING", name: "Vaulting", cost: 600, column: 4, row: 4, prereqs: ["TECH_ARCHITECTURE"], unlocks: { units: [], improvements: ["Cathedral"], laws: ["Iconography/Calligraphy"], projects: [] } },
                { id: "TECH_BODKIN_ARROW", name: "Bodkin Arrow", cost: 1000, column: 5, row: 5, prereqs: ["TECH_MANOR"], unlocks: { units: ["Longbowman"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_WINDLASS", name: "Windlass", cost: 1000, column: 5, row: 9, prereqs: ["TECH_MANOR", "TECH_HYDRAULICS"], unlocks: { units: ["Crossbowman"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_FISCAL_POLICY", name: "Fiscal Policy", cost: 1600, column: 6, row: 1, prereqs: ["TECH_LATEEN_SAIL", "TECH_JURISPRUDENCE"], unlocks: { units: [], improvements: [], laws: ["Coin Debasement/Monetary Reform"], projects: [] } },
                { id: "TECH_BARDING", name: "Barding", cost: 1600, column: 6, row: 2, prereqs: ["TECH_BATTLELINE", "TECH_MARTIAL_CODE"], unlocks: { units: ["Cataphract"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_INFANTRY_SQUARE", name: "Infantry Square", cost: 1600, column: 6, row: 7, prereqs: ["TECH_BATTLELINE"], unlocks: { units: ["Pikeman"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_COHORTS", name: "Cohorts", cost: 1600, column: 6, row: 6, prereqs: ["TECH_MANOR", "TECH_BATTLELINE"], unlocks: { units: ["Swordsman"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_CHAIN_DRIVE", name: "Chain Drive", cost: 1600, column: 6, row: 9, prereqs: ["TECH_WINDLASS"], unlocks: { units: ["Polybolos"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_BALLISTICS", name: "Ballistics", cost: 1600, column: 6, row: 10, prereqs: ["TECH_CARTOGRAPHY", "TECH_HYDRAULICS"], unlocks: { units: ["Mangonel"], improvements: [], laws: [], projects: [] } },
                { id: "TECH_ECONOMIC_REFORM", name: "Economic Reform", cost: 2000, column: 7, row: 1, prereqs: ["TECH_FISCAL_POLICY"], unlocks: { units: [], improvements: [], laws: [], projects: [] } },
                { id: "TECH_MILITARY_PRESTIGE", name: "Military Prestige", cost: 2000, column: 7, row: 5, prereqs: ["TECH_BARDING", "TECH_BODKIN_ARROW", "TECH_COHORTS"], unlocks: { units: [], improvements: [], laws: [], projects: [] } },
                { id: "TECH_INDUSTRIAL_PROGRESS", name: "Industrial Progress", cost: 2000, column: 7, row: 9, prereqs: ["TECH_CHAIN_DRIVE", "TECH_BALLISTICS"], unlocks: { units: [], improvements: [], laws: [], projects: [] } }
            ],
            bonusTechs: [
                { id: "TECH_STONECUTTING_BONUS_STONE", name: "Stone Boost", cost: 40, parent: "TECH_STONECUTTING", bonus: "+200 Stone" },
                { id: "TECH_ADMINISTRATION_BONUS_WORKER", name: "Free Worker", cost: 40, parent: "TECH_ADMINISTRATION", bonus: "+1 Worker" },
                { id: "TECH_HUSBANDRY_BONUS_FOOD", name: "Food Boost", cost: 60, parent: "TECH_HUSBANDRY", bonus: "+200 Food" },
                { id: "TECH_DRAMA_BONUS_SETTLER", name: "Free Settler", cost: 60, parent: "TECH_DRAMA", bonus: "+1 Settler" },
                { id: "TECH_ARISTOCRACY_BONUS_BORDERS", name: "Border Boost", cost: 60, parent: "TECH_ARISTOCRACY", bonus: "Border Growth" },
                { id: "TECH_NAVIGATION_BONUS_BIREME", name: "Free Bireme", cost: 100, parent: "TECH_STEEL", bonus: "+1 Bireme" },
                { id: "TECH_PHALANX_BONUS_ORDERS", name: "Orders Boost", cost: 100, parent: "TECH_PHALANX", bonus: "+20 Orders" },
                { id: "TECH_SPOKED_WHEEL_BONUS_CHARIOT", name: "Free Chariot", cost: 100, parent: "TECH_SOVEREIGNTY", bonus: "+1 Chariot" },
                { id: "TECH_FORESTRY_BONUS_SCIENTIST", name: "Free Scientist", cost: 100, parent: "TECH_METAPHYSICS", bonus: "Free Scientist" },
                { id: "TECH_STEEL_BONUS_TRAINING", name: "Training Boost", cost: 100, parent: "TECH_STEEL", bonus: "Unit Training" },
                { id: "TECH_SOVEREIGNITY_BONUS_CIVICS", name: "Civics Boost", cost: 100, parent: "TECH_SOVEREIGNTY", bonus: "Civic Points" },
                { id: "TECH_COINAGE_BONUS_MONEY", name: "Money Boost", cost: 200, parent: "TECH_COINAGE", bonus: "+200 Money" },
                { id: "TECH_CITIZENSHIP_BONUS_MINISTER", name: "Free Minister", cost: 200, parent: "TECH_CITIZENSHIP", bonus: "+1 Minister" },
                { id: "TECH_PORTCULLIS_BONUS_MACEMAN", name: "Free Maceman", cost: 200, parent: "TECH_PORTCULLIS", bonus: "+1 Maceman" },
                { id: "TECH_LAND_CONSOLIDATION_BONUS_CAMEL_ARCHER", name: "Free Camel Archer", cost: 200, parent: "TECH_MONASTICISM", bonus: "+1 Camel Archer" },
                { id: "TECH_LAND_CONSOLIDATION_BONUS_WAR_ELEPHANT", name: "Free War Elephant", cost: 200, parent: "TECH_MACHINERY", bonus: "+1 War Elephant" },
                { id: "TECH_COMPOSITE_BOW_BONUS_ARCHER", name: "Free Archer", cost: 100, parent: "TECH_FORESTRY", bonus: "+1 Archer" },
                { id: "TECH_MACHINERY_BONUS_ONAGER", name: "Free Onager", cost: 200, parent: "TECH_PORTCULLIS", bonus: "+1 Onager" },
                { id: "TECH_SCHOLARSHIP_BONUS_SCIENTIST", name: "Free Scientist", cost: 400, parent: "TECH_SCHOLARSHIP", bonus: "Free Scientist" },
                { id: "TECH_STIRRUPS_BONUS_HORSEMAN", name: "Free Horseman", cost: 200, parent: "TECH_LAND_CONSOLIDATION", bonus: "+1 Horseman" },
                { id: "TECH_STIRRUPS_BONUS_HORSE_ARCHER", name: "Free Horse Archer", cost: 200, parent: "TECH_LAND_CONSOLIDATION", bonus: "+1 Horse Archer" },
                { id: "TECH_MANOR_BONUS_GOODS", name: "Goods Bonus", cost: 200, parent: "TECH_MACHINERY", bonus: "Luxury Goods" },
                { id: "TECH_BATTLELINE_BONUS_SOLDIER", name: "Free Court Soldier", cost: 400, parent: "TECH_BATTLELINE", bonus: "Free Court Soldier" },
                { id: "TECH_HYDRAULICS_BONUS_BALLISTA", name: "Free Ballista", cost: 200, parent: "TECH_COMPOSITE_BOW", bonus: "+1 Ballista" },
                { id: "TECH_JURISPRUDENCE_BONUS_MINISTER", name: "Free Minister", cost: 600, parent: "TECH_JURISPRUDENCE", bonus: "+1 Minister" },
                { id: "TECH_VAULTING_BONUS_HAPPINESS", name: "Happiness Boost", cost: 400, parent: "TECH_VAULTING", bonus: "Happiness Boost" },
                { id: "TECH_BODKIN_ARROW_BONUS_LONGBOWMAN", name: "Free Longbowman", cost: 400, parent: "TECH_MANOR", bonus: "+2 Longbowman" },
                { id: "TECH_WINDLASS_BONUS_CROSSBOWMAN", name: "Free Crossbowman", cost: 400, parent: "TECH_HYDRAULICS", bonus: "+2 Crossbowman" },
                { id: "TECH_FISCAL_POLICY_BONUS_MERCHANT", name: "Free Merchant", cost: 1000, parent: "TECH_FISCAL_POLICY", bonus: "Free Merchant" },
                { id: "TECH_INFANTRY_SQUARE_BONUS_SOLDIER", name: "Free Court Soldier", cost: 1000, parent: "TECH_INFANTRY_SQUARE", bonus: "Free Court Soldier" },
                { id: "TECH_CHAIN_DRIVE_BONUS_MERCHANT", name: "Free Merchant", cost: 1000, parent: "TECH_CHAIN_DRIVE", bonus: "Free Merchant" },
                { id: "TECH_BATTERING_RAM_BONUS", name: "Free Battering Ram", cost: 100, parent: "TECH_SPOKED_WHEEL", bonus: "+1 Battering Ram", nation: "NATION_ASSYRIA" },
                { id: "TECH_SIEGE_TOWER_BONUS", name: "Free Siege Tower", cost: 600, parent: "TECH_WINDLASS", bonus: "+2 Siege Tower", nation: "NATION_ASSYRIA" },
                { id: "TECH_AKKADIAN_ARCHER_BONUS", name: "Free Akkadian Archer", cost: 100, parent: "TECH_FORESTRY", bonus: "+1 Akkadian Archer", nation: "NATION_BABYLONIA" },
                { id: "TECH_CIMMERIAN_ARCHER_BONUS", name: "Free Cimmerian Archer", cost: 600, parent: "TECH_BODKIN_ARROW", bonus: "+2 Cimmerian Archer", nation: "NATION_BABYLONIA" },
                { id: "TECH_AFRICAN_ELEPHANT_BONUS", name: "Free African Elephant", cost: 100, parent: "TECH_STEEL", bonus: "+1 African Elephant", nation: "NATION_CARTHAGE" },
                { id: "TECH_TURRETED_ELEPHANT_BONUS", name: "Free Turreted Elephant", cost: 600, parent: "TECH_MARTIAL_CODE", bonus: "+2 Turreted Elephant", nation: "NATION_CARTHAGE" },
                { id: "TECH_LIGHT_CHARIOT_BONUS", name: "Free Light Chariot", cost: 100, parent: "TECH_SPOKED_WHEEL", bonus: "+1 Light Chariot", nation: "NATION_EGYPT" },
                { id: "TECH_MOUNTED_LANCER_BONUS", name: "Free Mounted Lancer", cost: 600, parent: "TECH_MARTIAL_CODE", bonus: "+2 Mounted Lancer", nation: "NATION_EGYPT" },
                { id: "TECH_HOPLITE_BONUS", name: "Free Hoplite", cost: 100, parent: "TECH_PHALANX", bonus: "+1 Hoplite", nation: "NATION_GREECE" },
                { id: "TECH_PHALANGITE_BONUS", name: "Free Phalangite", cost: 600, parent: "TECH_MARTIAL_CODE", bonus: "+2 Phalangite", nation: "NATION_GREECE" },
                { id: "TECH_PALTON_CAVALRY_BONUS", name: "Free Palton Cavalry", cost: 100, parent: "TECH_FORESTRY", bonus: "+1 Palton Cavalry", nation: "NATION_PERSIA" },
                { id: "TECH_CATAPHRACT_ARCHER_BONUS", name: "Free Cataphract Archer", cost: 600, parent: "TECH_WINDLASS", bonus: "+2 Cataphract Archer", nation: "NATION_PERSIA" },
                { id: "TECH_HASTATUS_BONUS", name: "Free Hastatus", cost: 100, parent: "TECH_STEEL", bonus: "+1 Hastatus", nation: "NATION_ROME" },
                { id: "TECH_LEGIONARY_BONUS", name: "Free Legionary", cost: 600, parent: "TECH_MARTIAL_CODE", bonus: "+2 Legionary", nation: "NATION_ROME" },
                { id: "TECH_HITTITE_CHARIOT_1_BONUS", name: "Free Hittite Chariot", cost: 100, parent: "TECH_SPOKED_WHEEL", bonus: "+1 Hittite Chariot", nation: "NATION_HITTITE" },
                { id: "TECH_HITTITE_CHARIOT_2_BONUS", name: "Free Hittite Chariot", cost: 600, parent: "TECH_MARTIAL_CODE", bonus: "+2 Hittite Chariot", nation: "NATION_HITTITE" },
                { id: "TECH_MEDJAY_ARCHER_BONUS", name: "Free Medjay", cost: 100, parent: "TECH_FORESTRY", bonus: "+1 Medjay", nation: "NATION_KUSH" },
                { id: "TECH_BEJA_ARCHER_BONUS", name: "Free Beja Archer", cost: 600, parent: "TECH_BODKIN_ARROW", bonus: "+2 Beja Archer", nation: "NATION_KUSH" },
                { id: "TECH_DMT_WARRIOR_BONUS", name: "Free Dmt Warrior", cost: 100, parent: "TECH_STEEL", bonus: "+1 Dmt Warrior", nation: "NATION_AKSUM" },
                { id: "TECH_SHOTELAI_BONUS", name: "Free Shotelai", cost: 600, parent: "TECH_MARTIAL_CODE", bonus: "+2 Shotelai", nation: "NATION_AKSUM" },
                { id: "TECH_RESOURCE_SILK_BONUS", name: "Silk", cost: 200, parent: "TECH_COINAGE", bonus: "Silk" },
                { id: "TECH_RESOURCE_PORCELAIN_BONUS", name: "Porcelain", cost: 600, parent: "TECH_LATEEN_SAIL", bonus: "Porcelain" },
                { id: "TECH_RESOURCE_EXOTIC_FUR_BONUS", name: "Exotic Furs", cost: 100, parent: "TECH_SPOKED_WHEEL", bonus: "Exotic Furs" },
                { id: "TECH_RESOURCE_EBONY_BONUS", name: "Ebony", cost: 100, parent: "TECH_FORESTRY", bonus: "Ebony" },
                { id: "TECH_RESOURCE_PERFUME_BONUS", name: "Perfume", cost: 200, parent: "TECH_ARCHITECTURE", bonus: "Perfume" }
            ]
        };

        let researchedTechs = [];
        let researchOrder = [];
        let researchedBonusTechs = [];
        let selectedNation = '';

        // localStorage functions
        function saveToLocalStorage() {
            const state = {
                researchedTechs: researchedTechs,
                researchOrder: researchOrder,
                researchedBonusTechs: researchedBonusTechs,
                selectedNation: selectedNation,
                timestamp: Date.now()
            };
            localStorage.setItem('owtt-state', JSON.stringify(state));
        }

        function loadFromLocalStorage() {
            try {
                const stored = localStorage.getItem('owtt-state');
                if (stored) {
                    const state = JSON.parse(stored);
                    
                    // Restore state
                    researchedTechs = state.researchedTechs || [];
                    researchOrder = state.researchOrder || [];
                    researchedBonusTechs = state.researchedBonusTechs || [];
                    selectedNation = state.selectedNation || '';
                    
                    // Update UI
                    if (selectedNation) {
                        const select = document.getElementById('nationSelect');
                        if (select) {
                            select.value = selectedNation;
                        }
                    }
                    
                    console.log('Loaded state from localStorage:', state);
                    return true;
                }
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
            }
            return false;
        }

        function clearLocalStorage() {
            localStorage.removeItem('owtt-state');
        }

        // Nation lookup array for URL indices
        const nationLookup = [
            "NATION_AKSUM",
            "NATION_ASSYRIA", 
            "NATION_BABYLONIA",
            "NATION_CARTHAGE",
            "NATION_EGYPT",
            "NATION_GREECE",
            "NATION_HITTITE",
            "NATION_KUSH",
            "NATION_PERSIA",
            "NATION_ROME"
        ];

        const nationData = {
            startingTechs: {
                "NATION_AKSUM": [
                                "TECH_TRAPPING",
                                "TECH_LABOR_FORCE",
                                "TECH_ADMINISTRATION"
                ],
                "NATION_ASSYRIA": [
                                "TECH_TRAPPING",
                                "TECH_ADMINISTRATION",
                                "TECH_MILITARY_DRILL"
                ],
                "NATION_BABYLONIA": [
                                "TECH_TRAPPING",
                                "TECH_ADMINISTRATION",
                                "TECH_RHETORIC"
                ],
                "NATION_CARTHAGE": [
                                "TECH_TRAPPING",
                                "TECH_DIVINATION",
                                "TECH_ARISTOCRACY"
                ],
                "NATION_EGYPT": [
                                "TECH_IRONWORKING",
                                "TECH_STONECUTTING",
                                "TECH_LABOR_FORCE"
                ],
                "NATION_GREECE": [
                                "TECH_IRONWORKING",
                                "TECH_STONECUTTING",
                                "TECH_DRAMA"
                ],
                "NATION_HITTITE": [
                                "TECH_IRONWORKING",
                                "TECH_HUSBANDRY",
                                "TECH_ADMINISTRATION"
                ],
                "NATION_KUSH": [
                                "TECH_TRAPPING",
                                "TECH_STONECUTTING",
                                "TECH_DIVINATION"
                ],
                "NATION_PERSIA": [
                                "TECH_IRONWORKING",
                                "TECH_TRAPPING",
                                "TECH_HUSBANDRY"
                ],
                "NATION_ROME": [
                                "TECH_IRONWORKING",
                                "TECH_STONECUTTING",
                                "TECH_POLIS"
                ]
},
            nationSpecificBonuses: {
                "NATION_ASSYRIA": [
                                "TECH_BATTERING_RAM_BONUS",
                                "TECH_SIEGE_TOWER_BONUS"
                ],
                "NATION_BABYLONIA": [
                                "TECH_AKKADIAN_ARCHER_BONUS",
                                "TECH_CIMMERIAN_ARCHER_BONUS"
                ],
                "NATION_CARTHAGE": [
                                "TECH_AFRICAN_ELEPHANT_BONUS",
                                "TECH_TURRETED_ELEPHANT_BONUS"
                ],
                "NATION_EGYPT": [
                                "TECH_LIGHT_CHARIOT_BONUS",
                                "TECH_MOUNTED_LANCER_BONUS"
                ],
                "NATION_GREECE": [
                                "TECH_HOPLITE_BONUS",
                                "TECH_PHALANGITE_BONUS"
                ],
                "NATION_PERSIA": [
                                "TECH_PALTON_CAVALRY_BONUS",
                                "TECH_CATAPHRACT_ARCHER_BONUS"
                ],
                "NATION_ROME": [
                                "TECH_HASTATUS_BONUS",
                                "TECH_LEGIONARY_BONUS"
                ],
                "NATION_HITTITE": [
                                "TECH_HITTITE_CHARIOT_1_BONUS",
                                "TECH_HITTITE_CHARIOT_2_BONUS"
                ],
                "NATION_KUSH": [
                                "TECH_MEDJAY_ARCHER_BONUS",
                                "TECH_BEJA_ARCHER_BONUS"
                ],
                "NATION_AKSUM": [
                                "TECH_DMT_WARRIOR_BONUS",
                                "TECH_SHOTELAI_BONUS"
                ]
}
        };

        function initializeTechTree() {
            const techTree = document.getElementById('techTree');
            techTree.innerHTML = '';
            
            // Add tech nodes
            techData.techs.forEach(tech => {
                const node = document.createElement('div');
                node.className = 'tech-node';
                node.id = tech.id;
                node.style.gridColumn = tech.column + 1;
                node.style.gridRow = tech.row + 1;
                
                // Build unlocks display with emojis
                let unlocksHtml = '';
                const allUnlocks = [];
                
                if (tech.unlocks.units?.length > 0) {
                    tech.unlocks.units.forEach(unit => {
                        allUnlocks.push(`<span class="unlock-item">⚔️${unit}</span>`);
                    });
                }
                if (tech.unlocks.improvements?.length > 0) {
                    tech.unlocks.improvements.forEach(improvement => {
                        // Only show Kushite Pyramids if Kush is selected
                        if (improvement === "Kushite Pyramids" && selectedNation !== "NATION_KUSH") {
                            return;
                        }
                        allUnlocks.push(`<span class="unlock-item">🏗️${improvement}</span>`);
                    });
                }
                if (tech.unlocks.laws?.length > 0) {
                    tech.unlocks.laws.forEach(law => {
                        allUnlocks.push(`<span class="unlock-item">⚖️${law}</span>`);
                    });
                }
                if (tech.unlocks.projects?.length > 0) {
                    tech.unlocks.projects.forEach(project => {
                        allUnlocks.push(`<span class="unlock-item">🏛️${project}</span>`);
                    });
                }
                
                // Check if this tech has bonus techs available and add to unlocks
                const bonusTechs = techData.bonusTechs.filter(bonus => {
                    if (bonus.parent !== tech.id) return false;
                    // Only show nation-specific bonus cards if that nation is selected
                    if (bonus.nation && bonus.nation !== selectedNation) return false;
                    return true;
                });
                if (bonusTechs.length > 0) {
                    bonusTechs.forEach(bonusTech => {
                        // Use person emoji for courtiers, diamond for others
                        const isCourtier = bonusTech.name.includes('Minister') || 
                                         bonusTech.name.includes('Scientist') || 
                                         bonusTech.name.includes('Court Soldier') ||
                                         bonusTech.name.includes('Merchant');
                        const emoji = isCourtier ? '👤' : '💎';
                        allUnlocks.push(`<span class="unlock-item">${emoji}${bonusTech.name}</span>`);
                    });
                }
                
                if (allUnlocks.length > 0) {
                    unlocksHtml = `<div class="tech-unlocks">${allUnlocks.join('')}</div>`;
                }
                
                node.innerHTML = `
                    <div class="tech-name">${tech.name}</div>
                    ${unlocksHtml}
                `;
                
                node.addEventListener('click', () => toggleResearch(tech.id));
                node.addEventListener('mouseenter', (e) => showTooltip(e, tech));
                node.addEventListener('mouseleave', hideTooltip);
                
                techTree.appendChild(node);
            });
            
            // Initialize bonus tech section
            initializeBonusTechs();
            
            // Load state: URL params take priority over localStorage
            const urlParams = new URLSearchParams(window.location.search);
            const hasUrlParams = urlParams.has('n') || urlParams.has('nation') || urlParams.has('t') || urlParams.has('techs') || urlParams.has('b') || urlParams.has('bonus');
            
            if (hasUrlParams) {
                // Load from URL if present (for sharing links)
                loadFromUrl();
            } else {
                // Load from localStorage if no URL params
                loadFromLocalStorage();
            }
            
            updateTechStates();
            initializeBonusTechs();  // Re-render bonus cards with correct states
            updateOrderList();
            drawConnections();
        }

        function initializeBonusTechs() {
            const bonusTechGrid = document.getElementById('bonusTechGrid');
            bonusTechGrid.innerHTML = '';
            
            // Filter bonus techs based on selected nation
            const availableBonusTechs = techData.bonusTechs.filter(bonusTech => {
                // Show general bonus techs (no nation property)
                if (!bonusTech.nation) return true;
                // Show nation-specific bonus techs only if nation is selected and matches
                return selectedNation && bonusTech.nation === selectedNation;
            });
            
            // Group bonus techs by cost
            const costGroups = {};
            availableBonusTechs.forEach(bonusTech => {
                if (!costGroups[bonusTech.cost]) {
                    costGroups[bonusTech.cost] = [];
                }
                costGroups[bonusTech.cost].push(bonusTech);
            });
            
            // Sort cost groups by cost
            const sortedCosts = Object.keys(costGroups).map(Number).sort((a, b) => a - b);
            
            sortedCosts.forEach(cost => {
                // Create cost group container
                const costGroup = document.createElement('div');
                costGroup.className = 'bonus-cost-group';
                
                // Add cost header  
                const costHeader = document.createElement('div');
                costHeader.className = 'bonus-cost-header';
                costHeader.textContent = `${cost} 🧪`;
                costGroup.appendChild(costHeader);
                
                // Add cards column
                const cardsColumn = document.createElement('div');
                cardsColumn.className = 'bonus-cards-column';
                
                costGroups[cost].forEach(bonusTech => {
                    const node = document.createElement('div');
                    node.className = 'bonus-tech-node';
                    node.id = bonusTech.id;
                    
                    node.innerHTML = `
                        <div class="bonus-tech-name">${bonusTech.name}</div>
                        <div class="bonus-tech-parent">${bonusTech.bonus}</div>
                    `;
                    
                    node.addEventListener('click', () => toggleBonusResearch(bonusTech.id));
                    node.addEventListener('mouseenter', (e) => showBonusTooltip(e, bonusTech));
                    node.addEventListener('mouseleave', hideTooltip);
                    
                    cardsColumn.appendChild(node);
                });
                
                costGroup.appendChild(cardsColumn);
                bonusTechGrid.appendChild(costGroup);
            });
            
            updateBonusTechStates();
        }

        function toggleBonusResearch(bonusTechId) {
            const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
            if (!bonusTech) return;

            const index = researchedBonusTechs.indexOf(bonusTechId);
            if (index > -1) {
                // Remove bonus tech
                researchedBonusTechs.splice(index, 1);
            } else {
                // Add the parent tech and all its prerequisites first
                if (!researchedTechs.includes(bonusTech.parent)) {
                    // Add prerequisites of the parent tech using proper insertion order
                    const prereqsToAdd = getAllPrerequisites(bonusTech.parent);
                    prereqsToAdd.forEach(prereqId => {
                        if (!researchedTechs.includes(prereqId)) {
                            // Find the correct insertion point to maintain tech tree order
                            const insertIndex = findInsertionIndex(prereqId);
                            researchedTechs.splice(insertIndex, 0, prereqId);
                            researchOrder.splice(insertIndex, 0, Date.now() - (prereqsToAdd.length - prereqsToAdd.indexOf(prereqId)) * 1000);
                        }
                    });
                    
                    // Add the parent tech itself in the correct position
                    const parentInsertIndex = findInsertionIndex(bonusTech.parent);
                    researchedTechs.splice(parentInsertIndex, 0, bonusTech.parent);
                    researchOrder.splice(parentInsertIndex, 0, Date.now() - 500);
                }
                
                // Now add the bonus tech
                researchedBonusTechs.push(bonusTechId);
            }
            
            updateTechStates(); // Update main tech states too since we may have added main techs
            updateBonusTechStates();
            updateOrderList();
            drawConnections(); // Redraw connections since main techs may have changed
            saveToLocalStorage(); // Save state after changes
        }

        function updateBonusTechStates() {
            // Filter bonus techs based on selected nation - same logic as initializeBonusTechs
            const availableBonusTechs = techData.bonusTechs.filter(bonusTech => {
                // Show general bonus techs (no nation property)
                if (!bonusTech.nation) return true;
                // Show nation-specific bonus techs only if nation is selected and matches
                return selectedNation && bonusTech.nation === selectedNation;
            });
            
            availableBonusTechs.forEach(bonusTech => {
                const node = document.getElementById(bonusTech.id);
                if (node) {
                    node.classList.remove('available', 'researched');
                    
                    // Remove existing order badge
                    const existingBadge = node.querySelector('.tech-order-badge');
                    if (existingBadge) {
                        existingBadge.remove();
                    }
                    
                    if (researchedBonusTechs.includes(bonusTech.id)) {
                        node.classList.add('researched');
                        
                        // Add order badge - calculate position in overall research order
                        const allResearched = [...researchedTechs, ...researchedBonusTechs];
                        const overallIndex = allResearched.indexOf(bonusTech.id);
                        if (overallIndex > -1) {
                            const badge = document.createElement('div');
                            badge.className = 'tech-order-badge';
                            badge.textContent = overallIndex + 1;
                            node.appendChild(badge);
                        }
                    } else if (researchedTechs.includes(bonusTech.parent)) {
                        node.classList.add('available');
                    }
                }
            });
        }

        function showBonusTooltip(event, bonusTech) {
            const tooltip = document.getElementById('tooltip');
            const parentTech = techData.techs.find(t => t.id === bonusTech.parent);
            const parentName = parentTech ? parentTech.name : bonusTech.parent;
            
            tooltip.innerHTML = `
                <h3>${bonusTech.name}</h3>
                <p><strong>Cost:</strong> ${bonusTech.cost} Science</p>
                <p><strong>Requires:</strong> ${parentName}</p>
                <p><strong>Bonus:</strong> ${bonusTech.bonus}</p>
                <p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to toggle research</p>
            `;
            
            // Position tooltip accounting for scroll and viewport bounds
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // Check if tooltip would go off screen and adjust
            const viewportWidth = window.innerWidth;
            
            // If too far right, position to left of element
            if (left + 300 > viewportWidth + scrollLeft) {
                left = rect.left + scrollLeft - 310;
            }
            
            // If too high (near top), position below element
            if (rect.top < 150) {
                top = rect.bottom + scrollTop + 10;
            }
            
            // Ensure tooltip doesn't go above the viewport
            if (top < scrollTop + 10) {
                top = scrollTop + 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.add('show');
        }

        function toggleResearch(techId) {
            const index = researchedTechs.indexOf(techId);
            if (index > -1) {
                // Remove this tech and all techs that depend on it
                const techsToRemove = getTechsToRemove(techId);
                researchedTechs = researchedTechs.filter(id => !techsToRemove.includes(id));
                researchOrder = researchOrder.slice(0, researchedTechs.length);
            } else {
                // Add this tech and all its prerequisites
                const prereqsToAdd = getAllPrerequisites(techId);
                prereqsToAdd.forEach(prereqId => {
                    if (!researchedTechs.includes(prereqId)) {
                        researchedTechs.push(prereqId);
                        researchOrder.push(Date.now());
                    }
                });
                
                // Add the clicked tech itself if not already added
                if (!researchedTechs.includes(techId)) {
                    researchedTechs.push(techId);
                    researchOrder.push(Date.now());
                }
            }
            updateTechStates();
            updateBonusTechStates(); // Update bonus techs when main techs change
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after changes
        }

        function getAllPrerequisites(techId) {
            const visited = new Set();
            const result = [];
            
            // Get starting techs for current nation
            const startingTechs = selectedNation && nationData.startingTechs[selectedNation] 
                ? new Set(nationData.startingTechs[selectedNation]) 
                : new Set();
            
            function addPrereqs(id) {
                if (visited.has(id)) return;
                visited.add(id);
                
                // Skip if this is a starting tech (already have it)
                if (startingTechs.has(id)) return;
                
                const tech = techData.techs.find(t => t.id === id);
                if (!tech) return;
                
                // First add all prerequisites of this tech
                tech.prereqs.forEach(prereqId => {
                    // Skip if this prerequisite is a starting tech (already have it)
                    if (!startingTechs.has(prereqId)) {
                        addPrereqs(prereqId);
                    }
                });
                
                // Then add this tech (ensuring prerequisites come first)
                if (!result.includes(id)) {
                    result.push(id);
                }
            }
            
            const tech = techData.techs.find(t => t.id === techId);
            if (tech) {
                tech.prereqs.forEach(prereqId => {
                    // Skip if this prerequisite is a starting tech (already have it)
                    if (!startingTechs.has(prereqId)) {
                        addPrereqs(prereqId);
                    }
                });
            }
            
            return result;
        }
        
        function findInsertionIndex(techId) {
            // Find the correct position to insert a tech to maintain tech tree order
            // Insert after all prerequisites but before any techs that depend on this one
            
            const tech = techData.techs.find(t => t.id === techId);
            if (!tech) return researchedTechs.length;
            
            // Find latest prerequisite position
            let latestPrereqIndex = -1;
            tech.prereqs.forEach(prereqId => {
                const prereqIndex = researchedTechs.indexOf(prereqId);
                if (prereqIndex > latestPrereqIndex) {
                    latestPrereqIndex = prereqIndex;
                }
            });
            
            // Insert after the latest prerequisite
            return latestPrereqIndex + 1;
        }

        function getTechsToRemove(techId) {
            const toRemove = new Set([techId]);
            let changed = true;
            
            // Get starting techs for current nation - these should never be removed
            const startingTechs = selectedNation && nationData.startingTechs[selectedNation] 
                ? new Set(nationData.startingTechs[selectedNation]) 
                : new Set();
            
            // Keep finding techs that depend on techs we're removing
            while (changed) {
                changed = false;
                researchedTechs.forEach(id => {
                    if (!toRemove.has(id) && !startingTechs.has(id)) { // Never remove starting techs
                        const tech = techData.techs.find(t => t.id === id);
                        if (tech && tech.prereqs.some(prereq => toRemove.has(prereq))) {
                            // Check if this tech has alternative paths through starting techs
                            const hasAlternativePath = tech.prereqs.some(prereq => {
                                // If this prerequisite is being removed, check if we can reach this tech through starting techs
                                if (toRemove.has(prereq)) {
                                    return startingTechs.size > 0 && Array.from(startingTechs).some(startingTech => {
                                        return canReachTech(startingTech, id, new Set());
                                    });
                                }
                                return true; // This prerequisite is not being removed
                            });
                            
                            // Only remove if no alternative path exists
                            if (!hasAlternativePath) {
                                toRemove.add(id);
                                changed = true;
                            }
                        }
                    }
                });
            }
            
            return Array.from(toRemove);
        }

        function updateTechStates() {
            techData.techs.forEach(tech => {
                const node = document.getElementById(tech.id);
                node.classList.remove('researched', 'available');
                
                // Remove order badge
                const existingBadge = node.querySelector('.tech-order-badge');
                if (existingBadge) {
                    existingBadge.remove();
                }
                
                const techIndex = researchedTechs.indexOf(tech.id);
                if (techIndex > -1) {
                    node.classList.add('researched');
                    // Add order badge
                    const badge = document.createElement('div');
                    badge.className = 'tech-order-badge';
                    badge.textContent = techIndex + 1;
                    node.appendChild(badge);
                } else if (isAvailable(tech)) {
                    node.classList.add('available');
                }
            });
        }

        function isAvailable(tech) {
            return tech.prereqs.every(prereq => researchedTechs.includes(prereq));
        }

        function updateOrderList() {
            const list = document.getElementById('techOrderList');
            const totalCostElement = document.getElementById('totalCost');
            const totalLawsElement = document.getElementById('totalLaws');
            list.innerHTML = '';
            
            let totalCost = 0;
            let totalLaws = 0;
            let itemIndex = 1;
            
            // Create unified ordering: combine main techs with their associated bonus techs
            const unifiedOrder = [];
            
            // Add main techs in order
            researchedTechs.forEach((techId) => {
                unifiedOrder.push({ type: 'main', id: techId });
                
                // Add any bonus techs that belong to this main tech
                researchedBonusTechs.forEach((bonusTechId) => {
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    if (bonusTech && bonusTech.parent === techId) {
                        unifiedOrder.push({ type: 'bonus', id: bonusTechId });
                    }
                });
            });
            
            // Process the unified order
            unifiedOrder.forEach((item) => {
                if (item.type === 'main') {
                    const techId = item.id;
                const tech = techData.techs.find(t => t.id === techId);
                const isStartingTech = selectedNation && 
                    nationData.startingTechs[selectedNation] && 
                    nationData.startingTechs[selectedNation].includes(techId);
                
                if (!isStartingTech) {
                    totalCost += tech.cost;
                }
                
                // Count laws from this tech
                const hasLaws = tech.unlocks && tech.unlocks.laws && tech.unlocks.laws.length > 0;
                if (hasLaws) {
                    totalLaws += tech.unlocks.laws.length;
                }
                
                const listItem = document.createElement('div');
                listItem.className = 'tech-order-item';
                listItem.setAttribute('data-tech-id', techId);
                listItem.style.cursor = 'pointer';
                
                // Add law icon at the front if this tech unlocks laws
                const lawIcon = hasLaws ? '⚖️ ' : '';
                
                if (isStartingTech) {
                    listItem.innerHTML = `
                        <span class="tech-order-number">${itemIndex}.</span>
                        <span class="tech-order-name">${lawIcon}${tech.name}</span>
                        <span class="tech-order-cost"><span style="text-decoration: line-through; color: #888;">${tech.cost}</span> <strong style="color: #5a8a3a;">FREE</strong></span>
                    `;
                } else {
                    listItem.innerHTML = `
                        <span class="tech-order-number">${itemIndex}.</span>
                        <span class="tech-order-name">${lawIcon}${tech.name}</span>
                        <span class="tech-order-cost">${tech.cost}</span>
                    `;
                }
                
                // Add hover events for tooltip
                listItem.addEventListener('mouseenter', (e) => {
                    console.log('Tech tooltip triggered for:', tech.name);
                    showTooltip(e, tech);
                });
                listItem.addEventListener('mouseleave', hideTooltip);
                
                list.appendChild(listItem);
                itemIndex++;
                } else if (item.type === 'bonus') {
                    const bonusTechId = item.id;
                    const bonusTech = techData.bonusTechs.find(t => t.id === bonusTechId);
                    totalCost += bonusTech.cost;
                    
                    const listItem = document.createElement('div');
                    listItem.className = 'tech-order-item';
                    listItem.setAttribute('data-bonus-tech-id', bonusTechId);
                    listItem.style.backgroundColor = 'rgba(180, 160, 55, 0.2)'; // Highlight bonus techs
                    listItem.style.cursor = 'pointer';
                    listItem.innerHTML = `
                        <span class="tech-order-number">${itemIndex}.</span>
                        <span class="tech-order-name">💎 ${bonusTech.name}</span>
                        <span class="tech-order-cost">${bonusTech.cost}</span>
                    `;
                    
                    // Add hover events for bonus tech tooltip
                    listItem.addEventListener('mouseenter', (e) => {
                        console.log('Bonus tooltip triggered for:', bonusTech.name);
                        showBonusTooltip(e, bonusTech);
                    });
                    listItem.addEventListener('mouseleave', hideTooltip);
                    
                    list.appendChild(listItem);
                    itemIndex++;
                }
            });
            
            totalCostElement.textContent = `Total Cost: ${totalCost}`;
            totalLawsElement.textContent = `Laws Available: ${totalLaws}`;
            
            // Update clear button state
            const clearButton = document.querySelector('.clear-button');
            if (researchedTechs.length === 0 && researchedBonusTechs.length === 0) {
                clearButton.classList.add('disabled');
            } else {
                clearButton.classList.remove('disabled');
            }
        }

        let connections = []; // Store line objects for cleanup
        
        function drawConnections() {
            // Remove existing connections
            connections.forEach(line => line.remove());
            connections = [];
            
            // Draw connections using Leader Line (only for main techs, not bonus techs)
            techData.techs.forEach(tech => {
                if (tech.prereqs.length > 0) {
                    const toNode = document.getElementById(tech.id);
                    if (!toNode) return;
                    
                    tech.prereqs.forEach(prereqId => {
                        const fromNode = document.getElementById(prereqId);
                        if (fromNode) {
                            // Determine line color based on research status
                            let lineColor = '#4a3426'; // default
                            if (researchedTechs.includes(prereqId) && researchedTechs.includes(tech.id)) {
                                lineColor = '#5a8a3a'; // both researched
                            } else if (researchedTechs.includes(prereqId) && isAvailable(tech)) {
                                lineColor = '#b4a037'; // prereq researched, target available
                            }
                            
                            // Create line using Leader Line
                            const line = new LeaderLine(fromNode, toNode, {
                                color: lineColor,
                                size: 2,
                                path: 'straight',
                                startSocket: 'right',
                                endSocket: 'left',
                                startSocketGravity: 100,
                                endSocketGravity: 100
                            });
                            
                            connections.push(line);
                        }
                    });
                }
            });
        }

        function showTooltip(event, tech) {
            const tooltip = document.getElementById('tooltip');
            const prereqNames = tech.prereqs.map(id => {
                const prereqTech = techData.techs.find(t => t.id === id);
                return prereqTech ? prereqTech.name : id;
            }).join(', ');
            
            let unlocksList = '';
            const hasUnlocks = tech.unlocks.units?.length > 0 || tech.unlocks.projects?.length > 0 || 
                              tech.unlocks.improvements?.length > 0 || tech.unlocks.laws?.length > 0;
            const hasBonusTechs = techData.bonusTechs.some(bonus => {
                if (bonus.parent !== tech.id) return false;
                // Only count nation-specific bonus techs if that nation is selected
                if (bonus.nation && bonus.nation !== selectedNation) return false;
                return true;
            });
            
            if (hasUnlocks || hasBonusTechs) {
                unlocksList = '<div class="unlocks-list"><h4>Unlocks:</h4><ul>';
                if (tech.unlocks.units?.length > 0) {
                    tech.unlocks.units.forEach(unit => {
                        unlocksList += `<li>⚔️ ${unit}</li>`;
                    });
                }
                if (tech.unlocks.improvements?.length > 0) {
                    tech.unlocks.improvements.forEach(improvement => {
                        // Only show Kushite Pyramids if Kush is selected
                        if (improvement === "Kushite Pyramids" && selectedNation !== "NATION_KUSH") {
                            return;
                        }
                        unlocksList += `<li>🏗️ ${improvement}</li>`;
                    });
                }
                if (tech.unlocks.laws?.length > 0) {
                    tech.unlocks.laws.forEach(law => {
                        unlocksList += `<li>⚖️ ${law}</li>`;
                    });
                }
                if (tech.unlocks.projects?.length > 0) {
                    tech.unlocks.projects.forEach(project => {
                        unlocksList += `<li>🏛️ ${project}</li>`;
                    });
                }
                if (hasBonusTechs) {
                    const bonusTechs = techData.bonusTechs.filter(bonus => {
                        if (bonus.parent !== tech.id) return false;
                        // Only show nation-specific bonus techs if that nation is selected
                        if (bonus.nation && bonus.nation !== selectedNation) return false;
                        return true;
                    });
                    bonusTechs.forEach(bonusTech => {
                        unlocksList += `<li>💎 ${bonusTech.name}</li>`;
                    });
                }
                unlocksList += '</ul></div>';
            }
            
            tooltip.innerHTML = `
                <h3>${tech.name}</h3>
                <p><strong>Cost:</strong> ${tech.cost} Science</p>
                ${tech.prereqs.length > 0 ? `<p><strong>Prerequisites:</strong> ${prereqNames}</p>` : ''}
                ${unlocksList}
                <p style="margin-top: 8px; font-style: italic; color: #a09080;">Click to toggle research</p>
            `;
            
            // Position tooltip accounting for scroll and viewport
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Try to position to the right of the item, but adjust if it would go off-screen
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // If tooltip would go off the right edge, position it to the left
            if (left + 300 > window.innerWidth) { // Assuming tooltip is ~300px wide
                left = rect.left + scrollLeft - 310;
            }
            
            // If tooltip would go off the bottom, adjust upward
            if (top + 200 > window.innerHeight + scrollTop) { // Assuming tooltip is ~200px tall
                top = rect.bottom + scrollTop - 200;
            }
            
            tooltip.style.left = Math.max(10, left) + 'px'; // Don't go off left edge
            tooltip.style.top = Math.max(10, top) + 'px'; // Don't go off top edge
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }

        function showBonusTooltip(event, bonusTech) {
            const tooltip = document.getElementById('tooltip');
            
            // Find parent tech
            const parentTech = techData.techs.find(t => t.id === bonusTech.parent);
            const parentName = parentTech ? parentTech.name : bonusTech.parent;
            
            // Determine the appropriate emoji based on bonus content
            let bonusEmoji = '💎';
            if (bonusTech.bonus.includes('Stone') || bonusTech.bonus.includes('Iron') || bonusTech.bonus.includes('Food')) {
                bonusEmoji = '📦'; // Resources
            } else if (bonusTech.bonus.includes('Worker') || bonusTech.bonus.includes('Science')) {
                bonusEmoji = '🔬'; // Science/Workers
            } else if (bonusTech.bonus.includes('Courtier') || bonusTech.bonus.includes('General') || 
                      bonusTech.bonus.includes('Governor') || bonusTech.bonus.includes('Spymaster')) {
                bonusEmoji = '👤'; // Courtiers
            } else if (bonusTech.bonus.includes('+1') || bonusTech.bonus.includes('+2')) {
                bonusEmoji = '⚔️'; // Units
            }
            
            tooltip.innerHTML = `
                <h3>${bonusTech.name}</h3>
                <p><strong>Cost:</strong> ${bonusTech.cost} 🧪</p>
                <p><strong>Parent Tech:</strong> ${parentName}</p>
                <div class="unlocks-list">
                    <h4>Bonus:</h4>
                    <ul><li>${bonusEmoji} ${bonusTech.bonus}</li></ul>
                </div>
            `;
            
            // Position tooltip accounting for scroll and viewport
            const rect = event.target.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Try to position to the right of the item, but adjust if it would go off-screen
            let left = rect.right + scrollLeft + 10;
            let top = rect.top + scrollTop;
            
            // If tooltip would go off the right edge, position it to the left
            if (left + 300 > window.innerWidth) { // Assuming tooltip is ~300px wide
                left = rect.left + scrollLeft - 310;
            }
            
            // If tooltip would go off the bottom, adjust upward
            if (top + 200 > window.innerHeight + scrollTop) { // Assuming tooltip is ~200px tall
                top = rect.bottom + scrollTop - 200;
            }
            
            tooltip.style.left = Math.max(10, left) + 'px'; // Don't go off left edge
            tooltip.style.top = Math.max(10, top) + 'px'; // Don't go off top edge
            tooltip.classList.add('show');
        }

        function shareBuild() {
            if (researchedTechs.length === 0 && !selectedNation) {
                alert('No technologies researched or nation selected to share!');
                return;
            }
            
            const urlParts = [];
            
            // Add nation if selected (using numeric index)
            if (selectedNation) {
                const nationIndex = nationLookup.findIndex(n => n === selectedNation);
                if (nationIndex !== -1) {
                    urlParts.push(`n=${nationIndex}`);
                }
            }
            
            // Add techs if any are researched
            if (researchedTechs.length > 0) {
                const techNumbers = researchedTechs.map(techId => {
                    return techData.techs.findIndex(t => t.id === techId);
                }).filter(index => index !== -1);
                urlParts.push(`t=${techNumbers.join(',')}`);
            }
            
            // Add bonus techs if any are researched
            if (researchedBonusTechs.length > 0) {
                const bonusNumbers = researchedBonusTechs.map(bonusTechId => {
                    return techData.bonusTechs.findIndex(t => t.id === bonusTechId);
                }).filter(index => index !== -1);
                urlParts.push(`b=${bonusNumbers.join(',')}`);
            }
            
            const url = urlParts.length > 0 
                ? `https://alcaras.github.io/owtt/?${urlParts.join('&')}`
                : 'https://alcaras.github.io/owtt/';
            
            // Copy to clipboard and show feedback
            const shareButton = document.querySelector('.share-button');
            const originalText = shareButton.textContent;
            
            navigator.clipboard.writeText(url).then(() => {
                // Show "Copied!" feedback
                shareButton.textContent = 'Copied!';
                shareButton.style.background = 'linear-gradient(135deg, #4a8a4a, #6ab36a)';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    shareButton.textContent = originalText;
                    shareButton.style.background = 'linear-gradient(135deg, #8b6914, #b4a037)';
                }, 2000);
            }).catch(() => {
                // Fallback if clipboard API fails
                shareButton.textContent = 'Copy Failed';
                setTimeout(() => {
                    shareButton.textContent = originalText;
                }, 2000);
            });
        }

        function loadFromUrl() {
            const params = new URLSearchParams(window.location.search);
            
            // Load nation first (new format: n=index, old format: nation=NAME for backward compatibility)
            let nationParam = params.get('n');
            if (nationParam !== null) {
                const nationIndex = parseInt(nationParam);
                if (nationIndex >= 0 && nationIndex < nationLookup.length) {
                    selectedNation = nationLookup[nationIndex];
                }
            } else {
                // Backward compatibility with old format
                nationParam = params.get('nation');
                if (nationParam) {
                    selectedNation = nationParam;
                }
            }
            
            if (selectedNation) {
                const select = document.getElementById('nationSelect');
                select.value = selectedNation;
                
                // Add starting techs
                if (nationData.startingTechs[selectedNation]) {
                    const startingTechs = nationData.startingTechs[selectedNation];
                    startingTechs.forEach(techId => {
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    });
                }
            }
            
            // Load main techs (new format: t=1,2,3, old format: techs=1,2,3 for backward compatibility)
            let techsParam = params.get('t') || params.get('techs');
            if (techsParam) {
                const techNumbers = techsParam.split(',').map(n => parseInt(n)).filter(n => !isNaN(n));
                
                // Convert numbers back to tech IDs and validate
                techNumbers.forEach(techIndex => {
                    if (techIndex >= 0 && techIndex < techData.techs.length) {
                        const techId = techData.techs[techIndex].id;
                        const tech = techData.techs[techIndex];
                        
                        // Add prerequisites first
                        const prereqsToAdd = getAllPrerequisites(techId);
                        prereqsToAdd.forEach(prereqId => {
                            if (!researchedTechs.includes(prereqId)) {
                                researchedTechs.push(prereqId);
                                researchOrder.push(Date.now());
                            }
                        });
                        
                        // Add the tech itself
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    }
                });
            }
            
            // Load bonus techs (new format: b=1,2,3, old format: bonus=1,2,3 for backward compatibility)
            let bonusParam = params.get('b') || params.get('bonus');
            if (bonusParam) {
                const bonusNumbers = bonusParam.split(',').map(n => parseInt(n)).filter(n => !isNaN(n));
                
                bonusNumbers.forEach(bonusIndex => {
                    if (bonusIndex >= 0 && bonusIndex < techData.bonusTechs.length) {
                        const bonusTechId = techData.bonusTechs[bonusIndex].id;
                        if (!researchedBonusTechs.includes(bonusTechId)) {
                            researchedBonusTechs.push(bonusTechId);
                        }
                    }
                });
            }
            
            // Update displays
            initializeBonusTechs();
            updateOrderList();
        }

        function clearBuild() {
            const clearButton = document.querySelector('.clear-button');
            if (clearButton.classList.contains('disabled')) {
                return; // Don't clear if disabled
            }
            
            // Preserve the selected nation
            const currentNation = selectedNation;
            
            researchedTechs = [];
            researchOrder = [];
            researchedBonusTechs = [];
            
            // If a nation is selected, keep it selected and add its starting techs back
            if (currentNation) {
                selectedNation = currentNation;
                
                // Add starting techs for the selected nation
                if (nationData.startingTechs[currentNation]) {
                    const startingTechs = nationData.startingTechs[currentNation];
                    startingTechs.forEach(techId => {
                        if (!researchedTechs.includes(techId)) {
                            researchedTechs.push(techId);
                            researchOrder.push(Date.now());
                        }
                    });
                }
                
                // Keep nation selector value
                const select = document.getElementById('nationSelect');
                select.value = currentNation;
            } else {
                // Only reset nation if none was selected
                selectedNation = '';
                const select = document.getElementById('nationSelect');
                select.value = '';
            }
            
            initializeBonusTechs();
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after clearing
            
            // Clear URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        function selectNation() {
            const select = document.getElementById('nationSelect');
            selectedNation = select.value;
            
            // Clear current research when changing nations
            researchedTechs = [];
            researchOrder = [];
            researchedBonusTechs = [];
            
            // Add starting techs if a nation is selected
            if (selectedNation && nationData.startingTechs[selectedNation]) {
                const startingTechs = nationData.startingTechs[selectedNation];
                startingTechs.forEach(techId => {
                    if (!researchedTechs.includes(techId)) {
                        researchedTechs.push(techId);
                        researchOrder.push(Date.now());
                    }
                });
            }
            
            // Update the bonus tech display to show/hide nation-specific bonuses
            initializeBonusTechs();
            updateTechStates();
            updateBonusTechStates();
            updateOrderList();
            drawConnections();
            saveToLocalStorage(); // Save state after nation change
        }

        // Simulation functions
        function openSimulationPanel() {
            if (researchedTechs.length === 0) {
                alert('Please select some technologies to research first!');
                return;
            }
            
            document.getElementById('simulationOverlay').style.display = 'block';
            document.getElementById('simulationPanel').style.display = 'block';
            document.getElementById('simulationResults').style.display = 'none';
            
            // Show the run button and header text again when panel opens
            const runButton = document.querySelector('.sim-run-button');
            if (runButton) {
                runButton.style.display = 'inline-block';
                runButton.textContent = 'Run All Simulations';
                runButton.disabled = false;
            }
            
            // Show the title and description again
            const panelTitle = document.querySelector('#simulationPanel h3');
            const panelDescription = document.querySelector('#simulationPanel p');
            if (panelTitle) panelTitle.style.display = 'block';
            if (panelDescription) panelDescription.style.display = 'block';
        }

        function closeSimulationPanel() {
            document.getElementById('simulationOverlay').style.display = 'none';
            document.getElementById('simulationPanel').style.display = 'none';
        }

        function runSimulation() {
            // Show loading state
            const runButton = document.querySelector('.sim-run-button');
            const originalText = runButton.textContent;
            runButton.textContent = 'Running...';
            runButton.disabled = true;
            
            const loadingElement = document.getElementById('simulationLoading');
            const tableElement = document.getElementById('comparisonTable');
            if (loadingElement) loadingElement.style.display = 'block';
            if (tableElement) tableElement.style.display = 'none';
            
            // Run simulation after short delay to show loading state
            setTimeout(() => {
                const variants = [
                    { scholar: false, oracle: false, name: "Base" },
                    { scholar: false, oracle: true, name: "Oracle Only" },
                    { scholar: true, oracle: false, name: "Scholar Only" },
                    { scholar: true, oracle: true, name: "Scholar + Oracle" }
                ];
                
                const allResults = [];
                
                for (const variant of variants) {
                    console.log(`🚀 Starting variant: ${variant.name} (Scholar=${variant.scholar}, Oracle=${variant.oracle})`);
                    const results = simulateResearchPath(variant.scholar, variant.oracle, 1000);
                    console.log(`✅ Completed variant: ${variant.name}`, results);
                    
                    // Log Scholar redraw statistics if applicable
                    if (variant.scholar && results.scholarStats) {
                        console.log(`📜 Scholar Redraw Stats for ${variant.name}:`);
                        console.log(`   - Total redraws: ${results.scholarStats.totalRedraws}`);
                        console.log(`   - Successful redraws (found target): ${results.scholarStats.successfulRedraws}`);
                        console.log(`   - Average redraws per run: ${results.scholarStats.avgRedrawsPerRun.toFixed(2)}`);
                        console.log(`   - Redraw success rate: ${(results.scholarStats.redrawSuccessRate * 100).toFixed(1)}%`);
                    }
                    
                    allResults.push({
                        name: variant.name,
                        results: results
                    });
                }
                
                console.log('All simulation results:', allResults);
                displayComparisonResults(allResults);
                
                const loading = document.getElementById('simulationLoading');
                const panel = document.getElementById('simulationPanel');
                const overlay = document.getElementById('simulationOverlay');
                
                console.log('Elements found:');
                console.log('- loading element:', !!loading);
                console.log('- simulation panel:', !!panel);
                console.log('- simulation overlay:', !!overlay);
                
                if (panel) {
                    console.log('Panel display style:', panel.style.display);
                    console.log('Panel visibility:', panel.style.visibility);
                    console.log('Panel dimensions:', panel.offsetWidth, 'x', panel.offsetHeight);
                }
                
                if (loading) loading.style.display = 'none';
                console.log('Results should now be visible using div layout');
                
                // Hide the run button and header text after simulation completes
                runButton.style.display = 'none';
                
                // Hide the title and description to save space
                const panelTitle = document.querySelector('#simulationPanel h3');
                const panelDescription = document.querySelector('#simulationPanel p');
                if (panelTitle) panelTitle.style.display = 'none';
                if (panelDescription) panelDescription.style.display = 'none';
            }, 100);
        }

        function simulateResearchPath(hasScholar, hasOracle, numSimulations) {
            const results = [];
            
            // Build research path from current selections, excluding starting techs
            const researchPath = [
                ...researchedTechs.filter(techId => !isStartingTech(techId)),
                ...researchedBonusTechs
            ];
            
            // Debug: Calculate expected cost and compare to UI
            let expectedCost = 0;
            researchedTechs.forEach(techId => {
                if (!isStartingTech(techId)) {
                    const tech = techData.techs.find(t => t.id === techId);
                    if (tech) expectedCost += tech.cost;
                }
            });
            researchedBonusTechs.forEach(bonusId => {
                const bonus = techData.bonusTechs.find(t => t.id === bonusId);
                if (bonus) expectedCost += bonus.cost;
            });
            
            console.log(`🔍 DEBUG: Expected total cost: ${expectedCost}`);
            console.log(`🔍 DEBUG: Research path: ${researchPath.length} techs`);
            console.log(`🔍 DEBUG: Main techs (non-starting): ${researchedTechs.filter(techId => !isStartingTech(techId)).length}`);
            console.log(`🔍 DEBUG: Bonus techs: ${researchedBonusTechs.length}`);
            
            // Enable detailed debugging for Scholar simulations only
            window.debugSimulation = hasScholar;
            // Special debug mode for Stone Boost issue
            window.debugStoneBoost = hasScholar;
            
            for (let sim = 0; sim < numSimulations; sim++) {
                if (sim === 0) {
                    window.verboseFirstTurn = true; // Extra verbose logging for first turn
                } else if (sim === 100) {
                    window.debugSimulation = false; // Turn off debugging after first 100 runs
                    window.debugStoneBoost = false; // Turn off Stone Boost debugging after first 100 runs
                    window.verboseFirstTurn = false;
                }
                const result = simulateSingleRun(researchPath, hasScholar, hasOracle);
                if (result.failed) {
                    results.push({ 
                        failed: true, 
                        reason: result.reason, 
                        missedCards: result.missedCards,
                        scholarRedraws: result.scholarRedraws, 
                        scholarRedrawsSuccessful: result.scholarRedrawsSuccessful 
                    });
                } else {
                    results.push({ 
                        cost: result.cost, 
                        scholarRedraws: result.scholarRedraws, 
                        scholarRedrawsSuccessful: result.scholarRedrawsSuccessful 
                    });
                }
            }
            
            // Separate successful and failed runs
            const successfulRuns = results.filter(r => !r.failed);
            const failedRuns = results.filter(r => r.failed);
            
            // Calculate Scholar redraw statistics
            const scholarStats = {
                totalRedraws: results.reduce((sum, r) => sum + (r.scholarRedraws || 0), 0),
                successfulRedraws: results.reduce((sum, r) => sum + (r.scholarRedrawsSuccessful || 0), 0),
                avgRedrawsPerRun: 0,
                redrawSuccessRate: 0
            };
            
            if (hasScholar && results.length > 0) {
                scholarStats.avgRedrawsPerRun = scholarStats.totalRedraws / results.length;
                if (scholarStats.totalRedraws > 0) {
                    scholarStats.redrawSuccessRate = scholarStats.successfulRedraws / scholarStats.totalRedraws;
                }
            }
            
            if (successfulRuns.length === 0) {
                return { 
                    min: 0, max: 0, avg: 0, stdDev: 0, 
                    successRate: 0, 
                    failureReasons: failedRuns.reduce((acc, fail) => {
                        acc[fail.reason] = (acc[fail.reason] || 0) + 1;
                        return acc;
                    }, {}),
                    results: results 
                };
            }
            
            // Calculate statistics for successful runs
            const costs = successfulRuns.map(r => r.cost);
            const sortedResults = costs.sort((a, b) => a - b);
            const min = sortedResults[0];
            const max = sortedResults[sortedResults.length - 1];
            const avg = costs.reduce((sum, cost) => sum + cost, 0) / costs.length;
            
            // Calculate standard deviation
            const variance = costs.reduce((sum, cost) => sum + Math.pow(cost - avg, 2), 0) / costs.length;
            const stdDev = Math.sqrt(variance);
            
            const successRate = successfulRuns.length / results.length;
            const failureReasons = failedRuns.reduce((acc, fail) => {
                acc[fail.reason] = (acc[fail.reason] || 0) + 1;
                return acc;
            }, {});
            
            // Track which specific bonus cards are missed
            const missedBonusCards = {};
            failedRuns.forEach(fail => {
                if (fail.reason === 'missed_bonus_cards' && fail.missedCards) {
                    fail.missedCards.forEach(cardId => {
                        missedBonusCards[cardId] = (missedBonusCards[cardId] || 0) + 1;
                    });
                }
            });
            
            return { min, max, avg, stdDev, successRate, failureReasons, results, scholarStats, missedBonusCards };
        }

        function isStartingTech(techId) {
            return selectedNation && 
                   nationData.startingTechs[selectedNation] && 
                   nationData.startingTechs[selectedNation].includes(techId);
        }

        function simulateSingleRun(researchPath, hasScholar, hasOracle) {
            let completedTechs = new Set();
            let removedBonusCards = new Set(); // Track permanently removed bonus cards
            let totalCost = 0;
            let turnCount = 0;
            let scholarRedraws = 0; // Track number of redraws
            let scholarRedrawsSuccessful = 0; // Track successful redraws (found target)
            
            // PERSISTENT draw and discard piles across all turns
            let drawPile = [];
            let discardPile = [];
            let techsAlreadyInDeck = new Set(); // Track which techs are already in the deck
            
            if (window.debugSimulation) {
                console.log(`🎲 Starting simulation: Scholar=${hasScholar}, Oracle=${hasOracle}`);
                console.log(`🎯 Target techs: ${researchPath.map(id => {
                    const mainTech = techData.techs.find(t => t.id === id);
                    const bonusTech = techData.bonusTechs.find(t => t.id === id);
                    return (mainTech || bonusTech)?.name || id;
                }).join(', ')}`);
            }
            
            // Add starting techs as already completed
            if (selectedNation && nationData.startingTechs[selectedNation]) {
                nationData.startingTechs[selectedNation].forEach(techId => {
                    completedTechs.add(techId);
                });
                if (window.debugSimulation) {
                    console.log(`🏛️ Starting techs: ${Array.from(completedTechs).map(id => {
                        const tech = techData.techs.find(t => t.id === id);
                        return tech?.name || id;
                    }).join(', ')}`);
                }
            }
            
            // Separate main techs and bonus cards in research path
            const targetMainTechs = researchPath.filter(id => techData.techs.some(t => t.id === id));
            const targetBonusCards = researchPath.filter(id => techData.bonusTechs.some(t => t.id === id));
            const targetTechSet = new Set(researchPath);
            
            if (window.debugSimulation && targetBonusCards.length > 0) {
                console.log(`🎁 Target bonus cards: ${targetBonusCards.map(id => {
                    const bonus = techData.bonusTechs.find(t => t.id === id);
                    return bonus?.name || id;
                }).join(', ')}`);
            }
            
            // Keep researching until all target techs are completed
            while (!isSubset(targetTechSet, completedTechs) && turnCount < 500) {
                turnCount++;
                
                // Check if any required bonus cards have been permanently removed
                const missedBonusCards = targetBonusCards.filter(id => removedBonusCards.has(id));
                if (missedBonusCards.length > 0) {
                    if (window.debugSimulation) {
                        console.warn(`💔 Failed: Required bonus cards permanently lost: ${missedBonusCards.map(id => {
                            const bonus = techData.bonusTechs.find(t => t.id === id);
                            return bonus?.name || id;
                        }).join(', ')}`);
                    }
                    return { cost: -1, failed: true, reason: 'missed_bonus_cards', missedCards: missedBonusCards };
                }
                
                // For turn 1 with a nation, only add Tier 1 techs and their bonus cards
                let availableTechs;
                if (turnCount === 1 && selectedNation) {
                    // First turn with nation: only Tier 1 techs not already owned
                    const tier1TechIds = ["TECH_IRONWORKING", "TECH_STONECUTTING", "TECH_TRAPPING", "TECH_DIVINATION", "TECH_ADMINISTRATION"];
                    availableTechs = techData.techs.filter(tech => {
                        return tier1TechIds.includes(tech.id) && !completedTechs.has(tech.id) && !isStartingTech(tech.id);
                    });
                    
                    // For Kush, also add the Stone Boost card since they start with Stonecutting
                    if (selectedNation === "NATION_KUSH") {
                        const stoneBoost = techData.bonusTechs.find(b => b.id === "TECH_STONECUTTING_BONUS_STONE");
                        if (stoneBoost && !removedBonusCards.has(stoneBoost.id)) {
                            stoneBoost.isBonus = true;
                            availableTechs.push(stoneBoost);
                        }
                    }
                } else {
                    // Normal turn: get all available techs based on prerequisites
                    availableTechs = getAvailableTechs(completedTechs, removedBonusCards);
                }
                
                // Only add NEW techs to the draw pile (techs that weren't available before)
                const newlyAvailableTechs = availableTechs.filter(tech => !techsAlreadyInDeck.has(tech.id));
                
                if (newlyAvailableTechs.length > 0) {
                    // Add new techs to draw pile and shuffle them in
                    newlyAvailableTechs.forEach(tech => {
                        techsAlreadyInDeck.add(tech.id);
                        drawPile.push(tech);
                    });
                    shuffleArray(drawPile);
                    
                    if (window.debugSimulation) {
                        console.log(`🆕 Added ${newlyAvailableTechs.length} newly available techs to draw pile`);
                        if (window.verboseFirstTurn && turnCount === 1) {
                            console.log(`  New techs: ${newlyAvailableTechs.map(t => `${t.name}(${t.cost})`).join(', ')}`);
                        }
                    }
                }
                
                if (window.debugSimulation && turnCount === 1) {
                    const mainCount = availableTechs.filter(t => !t.isBonus).length;
                    const bonusCount = availableTechs.filter(t => t.isBonus).length;
                    console.log(`📚 Total available techs: ${mainCount} main + ${bonusCount} bonus = ${availableTechs.length} total`);
                    
                    if (window.verboseFirstTurn) {
                        console.log(`\n🔍 VERBOSE: First Turn Draw Pile Details:`);
                        console.log(`Draw pile has ${drawPile.length} cards:`);
                        
                        // Group by type and cost
                        const mainTechs = drawPile.filter(t => !t.isBonus).sort((a, b) => a.cost - b.cost);
                        const bonusTechs = drawPile.filter(t => t.isBonus).sort((a, b) => a.cost - b.cost);
                        
                        console.log(`\n  Main Techs (${mainTechs.length}):`);
                        mainTechs.forEach(t => {
                            const isTarget = targetTechSet.has(t.id);
                            console.log(`    ${isTarget ? '🎯' : '  '} ${t.name} (${t.cost} 🧪) - ${t.id}`);
                        });
                        
                        console.log(`\n  Bonus Cards (${bonusTechs.length}):`);
                        bonusTechs.forEach(t => {
                            const isTarget = targetTechSet.has(t.id);
                            console.log(`    ${isTarget ? '🎯' : '  '} ${t.name} (${t.cost} 🧪) - ${t.id}`);
                        });
                        
                        console.log(`\nDiscard pile: ${discardPile.length} cards`);
                        console.log(`Target techs we're looking for: ${Array.from(targetTechSet).join(', ')}`);
                    }
                }
                
                // Research one tech this turn
                const result = researchOneTurn(targetTechSet, drawPile, discardPile, completedTechs, hasScholar, hasOracle, turnCount, removedBonusCards, { scholarRedraws, scholarRedrawsSuccessful });
                if (result.cost >= 0) {
                    totalCost += result.cost;
                    if (result.removedBonusCards) {
                        result.removedBonusCards.forEach(id => removedBonusCards.add(id));
                    }
                    // Update redraw tracking
                    if (result.redrawStats) {
                        scholarRedraws = result.redrawStats.scholarRedraws;
                        scholarRedrawsSuccessful = result.redrawStats.scholarRedrawsSuccessful;
                    }
                } else {
                    if (window.debugSimulation) {
                        console.warn('⚠️ No progress made this turn, ending simulation');
                    }
                    break;
                }
            }
            
            // Check final success/failure
            const success = isSubset(targetTechSet, completedTechs);
            
            if (window.debugSimulation) {
                console.log(`🏁 Simulation ${success ? 'SUCCESS' : 'FAILED'} after ${turnCount} turns, total cost: ${totalCost}`);
                if (!success) {
                    const remaining = Array.from(targetTechSet).filter(id => !completedTechs.has(id));
                    console.log(`❌ Missing techs: ${remaining.join(', ')}`);
                }
            }
            
            return success ? { 
                cost: totalCost, 
                failed: false,
                scholarRedraws,
                scholarRedrawsSuccessful
            } : { 
                cost: -1, 
                failed: true, 
                reason: 'incomplete', 
                totalCost,
                scholarRedraws,
                scholarRedrawsSuccessful
            };
        }

        function isSubset(subset, superset) {
            for (const item of subset) {
                if (!superset.has(item)) {
                    return false;
                }
            }
            return true;
        }

        function getAvailableTechs(completedTechs, removedBonusCards = new Set()) {
            const availableMainTechs = techData.techs.filter(tech => {
                // Skip if already completed or is a starting tech
                if (completedTechs.has(tech.id) || isStartingTech(tech.id)) {
                    return false;
                }
                
                // Check if all prerequisites are met
                return (tech.prereqs || []).every(prereqId => completedTechs.has(prereqId));
            });
            
            const availableBonusCards = techData.bonusTechs.filter(bonus => {
                // Skip if already completed or permanently removed
                if (completedTechs.has(bonus.id) || removedBonusCards.has(bonus.id)) {
                    return false;
                }
                
                // Filter by nation - same logic as initializeBonusTechs
                if (bonus.nation && (!selectedNation || bonus.nation !== selectedNation)) {
                    return false;
                }
                
                // Bonus cards require their parent tech to be completed
                if (bonus.parent && !completedTechs.has(bonus.parent)) {
                    return false;
                }
                
                return true;
            });
            
            // Mark bonus cards so we can identify them later
            availableBonusCards.forEach(bonus => {
                bonus.isBonus = true;
            });
            
            return [...availableMainTechs, ...availableBonusCards];
        }

        function researchOneTurn(targetTechSet, drawPile, discardPile, completedTechs, hasScholar, hasOracle, turnCount, removedBonusCards, redrawStats = { scholarRedraws: 0, scholarRedrawsSuccessful: 0 }) {
            const callId = Math.random().toString(36).substr(2, 9);
            if (window.debugStoneBoost) {
                console.log(`📞 FUNCTION CALL: researchOneTurn [Call ID: ${callId}] Turn ${turnCount}`);
            }
            if (window.debugSimulation) {
                console.log(`\n--- Turn ${turnCount} ---`);
                console.log(`📊 Draw pile: ${drawPile.length}, Discard pile: ${discardPile.length}, Completed: ${completedTechs.size}`);
                console.log(`🔮 Oracle: ${hasOracle ? 'YES (+1 card)' : 'NO'}, 📜 Scholar: ${hasScholar ? 'YES (redraw available)' : 'NO'}`);
                
                if (window.verboseFirstTurn && turnCount === 1) {
                    console.log(`\n🔍 VERBOSE: Draw/Discard State Before Drawing Hand:`);
                    console.log(`  Draw pile: ${drawPile.length} cards`);
                    console.log(`  Discard pile: ${discardPile.length} cards`);
                }
            }
            
            // Draw hand from available techs
            let hand = [];
            let expectedHandSize;
            if (turnCount === 1) {
                // Special handling for Turn 1 - guaranteed Tier 1 techs
                hand = drawFirstHand(drawPile, discardPile, hasOracle);
                expectedHandSize = hand.length; // First turn draws all available
            } else {
                // Normal draw for subsequent turns
                expectedHandSize = hasOracle ? 5 : 4;
                hand = drawHand(drawPile, discardPile, expectedHandSize);
            }
            
            if (hand.length === 0) {
                if (window.debugSimulation) {
                    console.warn('⚠️ No techs available to draw');
                }
                return { cost: 0, redrawStats };
            }
            
            if (window.debugSimulation && turnCount > 1 && window.debugStoneBoost) {
                console.log(`✋ Hand (${hand.length}/${expectedHandSize}): ${hand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
            }
            
            // Look for target techs in hand
            const targetsInHand = hand.filter(tech => targetTechSet.has(tech.id));
            const bonusTargetsInHand = targetsInHand.filter(tech => tech.isBonus);
            const mainTargetsInHand = targetsInHand.filter(tech => !tech.isBonus);
            
            // DEBUG: Special logging for Stone Boost case
            if (window.debugStoneBoost) {
                const stoneBoostInHand = hand.find(tech => tech.id === "TECH_STONECUTTING_BONUS_STONE");
                if (stoneBoostInHand) {
                    console.log(`🔍 STONE BOOST DEBUG: Stone Boost is in hand!`);
                    console.log(`  - Full hand: ${hand.map(t => t.name).join(', ')}`);
                    console.log(`  - Is Stone Boost a target? ${targetTechSet.has(stoneBoostInHand.id)}`);
                    console.log(`  - Target set contains: ${Array.from(targetTechSet).join(', ')}`);
                    console.log(`  - Stone Boost marked as bonus? ${stoneBoostInHand.isBonus}`);
                    console.log(`  - Targets in hand: ${targetsInHand.map(t => t.name).join(', ')}`);
                    console.log(`  - Bonus targets in hand: ${bonusTargetsInHand.map(t => t.name).join(', ')}`);
                    console.log(`  - Main targets in hand: ${mainTargetsInHand.map(t => t.name).join(', ')}`);
                }
            }
            
            let bestChoice = null;
            
            if (targetsInHand.length > 0) {
                // ALWAYS prioritize bonus cards since they're permanently lost if discarded
                if (bonusTargetsInHand.length > 0) {
                    if (bonusTargetsInHand.length > 1) {
                        if (window.debugSimulation) {
                            console.warn(`⚠️ Multiple target bonus cards in hand! Can only choose one:`);
                            bonusTargetsInHand.forEach(bonus => {
                                console.warn(`   - ${bonus.name}`);
                            });
                        }
                        // Choose the most expensive bonus card (arbitrary strategy)
                        bestChoice = bonusTargetsInHand.reduce((mostExpensive, bonus) => 
                            bonus.cost > mostExpensive.cost ? bonus : mostExpensive
                        );
                        if (window.debugSimulation) {
                            console.log(`🎯 Choosing most expensive bonus: ${bestChoice.name} (${bestChoice.cost} 🧪)`);
                        }
                    } else {
                        // Single bonus card - select it
                        bestChoice = bonusTargetsInHand[0];
                        if (window.debugSimulation) {
                            console.log(`🎁 Prioritizing bonus card: ${bestChoice.name} (bonus cards are lost if discarded)`);
                        }
                        if (window.debugStoneBoost && bestChoice.id === "TECH_STONECUTTING_BONUS_STONE") {
                            console.log(`✅ STONE BOOST SELECTED: Successfully choosing Stone Boost as priority bonus card!`);
                        }
                    }
                } else if (mainTargetsInHand.length > 0) {
                    // No bonus cards, pick the first main tech
                    bestChoice = mainTargetsInHand[0];
                    if (window.debugSimulation) {
                        console.log(`🔬 Found target main tech: ${bestChoice.name}`);
                    }
                    // This should never happen if Stone Boost is in hand as a target!
                    if (window.debugStoneBoost && hand.some(t => t.id === "TECH_STONECUTTING_BONUS_STONE")) {
                        console.log(`🚨 BUG: Choosing main tech ${bestChoice.name} when Stone Boost is in hand!`);
                        console.log(`  - bonusTargetsInHand.length = ${bonusTargetsInHand.length}`);
                        console.log(`  - bonusTargetsInHand = ${bonusTargetsInHand.map(t => t.name)}`);
                    }
                }
            } else {
                // No target tech in hand - consider Scholar redraw
                if (hasScholar && shouldRedrawForTargets(hand, targetTechSet, drawPile, discardPile)) {
                    redrawStats.scholarRedraws++;
                    if (window.debugSimulation) {
                        console.log(`📜 Scholar redraw #${redrawStats.scholarRedraws}: Looking for target techs...`);
                    }
                    
                    // Discard current hand and redraw
                    // IMPORTANT: Bonus cards are permanently removed, not discarded!
                    hand.forEach(tech => {
                        if (tech.isBonus) {
                            // Bonus cards are permanently removed when discarded
                            removedBonusCards.add(tech.id);
                            if (window.debugSimulation) {
                                console.log(`💔 Bonus card permanently removed during Scholar redraw: ${tech.name}`);
                            }
                            if (window.debugStoneBoost && tech.id === "TECH_STONECUTTING_BONUS_STONE") {
                                console.log(`🚨 STONE BOOST LOST IN REDRAW: Stone Boost was discarded during Scholar redraw!`);
                                console.log(`  - Was Stone Boost a target? ${targetTechSet.has(tech.id)}`);
                                console.log(`  - Why did we redraw with Stone Boost in hand?`);
                            }
                        } else {
                            // Main techs go to discard pile
                            discardPile.push(tech);
                        }
                    });
                    hand = drawHand(drawPile, discardPile, expectedHandSize);  // Update hand to the new draw
                    
                    if (window.debugSimulation) {
                        console.log(`✋ New hand (${hand.length}): ${hand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
                    }
                    
                    // Apply same target prioritization logic as main selection
                    const newTargetsInHand = hand.filter(tech => targetTechSet.has(tech.id));
                    const newBonusTargetsInHand = newTargetsInHand.filter(tech => tech.isBonus);
                    const newMainTargetsInHand = newTargetsInHand.filter(tech => !tech.isBonus);
                    
                    if (newTargetsInHand.length > 0) {
                        // ALWAYS prioritize bonus cards since they're permanently lost if discarded
                        if (newBonusTargetsInHand.length > 0) {
                            if (newBonusTargetsInHand.length > 1) {
                                // Choose the most expensive bonus card (arbitrary strategy)
                                bestChoice = newBonusTargetsInHand.reduce((mostExpensive, bonus) => 
                                    bonus.cost > mostExpensive.cost ? bonus : mostExpensive
                                );
                            } else {
                                // Single bonus card - select it
                                bestChoice = newBonusTargetsInHand[0];
                            }
                        } else {
                            // No bonus cards, pick the first main tech
                            bestChoice = newMainTargetsInHand[0];
                        }
                        
                        redrawStats.scholarRedrawsSuccessful++;
                        if (window.debugSimulation) {
                            const techType = bestChoice.isBonus ? '🎁 bonus' : '🔬 main';
                            console.log(`✅ Found target ${techType} in redraw! Selecting: ${bestChoice.name} (Success rate: ${redrawStats.scholarRedrawsSuccessful}/${redrawStats.scholarRedraws})`);
                        }
                    } else if (hand.length > 0) {
                        // Pick cheapest from new hand
                        // Even non-target bonus cards can be picked if they're cheapest
                        bestChoice = hand.reduce((cheapest, tech) => 
                            tech.cost < cheapest.cost ? tech : cheapest
                        );
                        if (window.debugSimulation) {
                            const techType = bestChoice.isBonus ? '🎁 bonus' : '🔬 main';
                            console.log(`💰 No target in redraw, picking cheapest ${techType}: ${bestChoice.name} (${bestChoice.cost} 🧪)`);
                        }
                    }
                } else {
                    // No redraw - pick cheapest to advance deck
                    // Even non-target bonus cards can be picked if they're cheapest
                    bestChoice = hand.reduce((cheapest, tech) => 
                        tech.cost < cheapest.cost ? tech : cheapest
                    );
                    if (window.debugSimulation) {
                        const techType = bestChoice.isBonus ? '🎁 bonus' : '🔬 main';
                        console.log(`💰 No target, picking cheapest ${techType}: ${bestChoice.name} (${bestChoice.cost} 🧪)`);
                    }
                }
            }
            
            if (bestChoice) {
                // DEBUG: Log what was actually selected
                if (window.debugStoneBoost && hand.some(t => t.id === "TECH_STONECUTTING_BONUS_STONE")) {
                    console.log(`🎯 FINAL SELECTION when Stone Boost in hand: ${bestChoice.name} [Call ID: ${callId}]`);
                    console.log(`  - bestChoice.id = ${bestChoice.id}`);
                    console.log(`  - Is this Stone Boost? ${bestChoice.id === "TECH_STONECUTTING_BONUS_STONE"}`);
                }
                
                completedTechs.add(bestChoice.id);
                
                // Handle discarded cards - bonus cards are permanently removed
                const removedThisTurn = [];
                hand.forEach(tech => {
                    if (tech.id !== bestChoice.id) {
                        if (tech.isBonus) {
                            // Bonus cards are permanently removed
                            removedBonusCards.add(tech.id);
                            removedThisTurn.push(tech.id);
                            if (window.debugSimulation) {
                                console.log(`💔 Bonus card permanently removed: ${tech.name}`);
                            }
                            if (window.debugStoneBoost && tech.id === "TECH_STONECUTTING_BONUS_STONE") {
                                console.log(`🚨 STONE BOOST LOST: Stone Boost was discarded instead of selected!`);
                                console.log(`  - Selected instead: ${bestChoice.name}`);
                                console.log(`  - Was Stone Boost a target? ${targetTechSet.has(tech.id)}`);
                            }
                        } else {
                            // Main techs go to discard pile
                            discardPile.push(tech);
                            if (window.verboseFirstTurn && window.debugSimulation) {
                                console.log(`♻️ Main tech discarded: ${tech.name} (${tech.cost} 🧪) -> discard pile`);
                            }
                        }
                    }
                });
                
                if (window.debugSimulation) {
                    const techType = bestChoice.isBonus ? '🎁 BONUS' : '🔬 MAIN';
                    console.log(`${techType} Researched: ${bestChoice.name} - now completed!`);
                    console.log(`📊 Post-research: Draw pile=${drawPile.length}, Discard pile=${discardPile.length}`);
                }
                
                return { 
                    cost: bestChoice.cost, 
                    removedBonusCards: removedThisTurn.length > 0 ? removedThisTurn : null,
                    redrawStats
                };
            }
            
            return { cost: 0, redrawStats };
        }

        function drawFirstHand(drawPile, discardPile, hasOracle) {
            // Special first draw rules:
            // - If nation selected: guaranteed ALL the Tier 1 techs that nation doesn't have
            //   - Most nations: 3 Tier 1 techs
            //   - Kush: 2 Tier 1 techs + Stone Boost bonus card
            // - If no nation: draw 5 cards including all Tier 1 techs
            // - Oracle doesn't affect first draw
            
            const hand = [];
            
            if (selectedNation) {
                // With a nation: draw ALL available cards (should be just the Tier 1s not owned)
                while (drawPile.length > 0) {
                    hand.push(drawPile.pop());
                }
            } else {
                // No nation selected - draw 5 cards
                for (let i = 0; i < 5 && drawPile.length > 0; i++) {
                    hand.push(drawPile.pop());
                }
            }
            
            if (window.debugSimulation) {
                console.log(`✋ First hand (${hand.length}): ${hand.map(t => `${t.name}(${t.cost})`).join(', ')}`);
                if (selectedNation === "NATION_KUSH" && hand.some(t => t.id === "TECH_STONECUTTING_BONUS_STONE")) {
                    console.log(`  📜 Kush special: Includes Stone Boost bonus card`);
                }
            }
            
            return hand;
        }
        
        function drawHand(drawPile, discardPile, handSize) {
            const hand = [];
            
            for (let i = 0; i < handSize; i++) {
                // Reshuffle if draw pile is empty
                if (drawPile.length === 0 && discardPile.length > 0) {
                    if (window.debugSimulation) {
                        console.log(`🔄 Reshuffling: Moving ${discardPile.length} cards from discard to draw pile`);
                    }
                    drawPile.push(...discardPile);
                    discardPile.length = 0;
                    shuffleArray(drawPile);
                    if (window.debugSimulation) {
                        console.log(`🃏 Draw pile shuffled, now has ${drawPile.length} cards`);
                    }
                }
                
                // Draw from pile if available
                if (drawPile.length > 0) {
                    hand.push(drawPile.pop());
                }
            }
            
            return hand;
        }

        function shouldRedrawForTargets(hand, targetTechSet, drawPile, discardPile) {
            // Simple Scholar redraw logic: if we don't have a target and one exists, redraw!
            const allAvailableCards = [...drawPile, ...discardPile];
            const targetStillAvailable = allAvailableCards.some(tech => targetTechSet.has(tech.id));
            
            // Just redraw if any target is still available - be aggressive!
            const shouldRedraw = targetStillAvailable;
            
            if (window.debugSimulation) {
                const targetCount = allAvailableCards.filter(tech => targetTechSet.has(tech.id)).length;
                const targetProbability = targetCount / allAvailableCards.length;
                console.log(`📜 Scholar: ${targetCount} targets in ${allAvailableCards.length} cards (${Math.round(targetProbability*100)}% chance) - redraw=${shouldRedraw ? 'YES' : 'NO'}`);
            }
            
            return shouldRedraw;
        }


        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function displayComparisonResults(allResults) {
            console.log('displayComparisonResults called with:', allResults);
            
            // Try a different approach - replace the entire table with a simple div
            const container = document.getElementById('simulationResults');
            if (!container) {
                console.error('Could not find simulationResults container');
                console.log('Available elements with IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id));
                return;
            }
            
            console.log('Container found:', container);
            console.log('Container current content:', container.innerHTML);
            console.log('Container parent:', container.parentElement?.tagName, container.parentElement?.id);
            
            // Find min/max values for scaling
            const allMins = allResults.map(r => r.results.min);
            const allMaxs = allResults.map(r => r.results.max);
            const allAvgs = allResults.map(r => r.results.avg);
            const globalMin = Math.min(...allMins);
            const globalMax = Math.max(...allMaxs);
            const range = globalMax - globalMin;
            
            let html = `
                <div style="color: #d4af37; font-size: 1.1em; margin-bottom: 15px; text-align: center;">
                    📊 Research Cost Comparison (1000 runs each)
                </div>
                <div style="background: rgba(139, 105, 20, 0.15); padding: 15px; border-radius: 8px; border: 1px solid #8b6914;">
            `;
            
            for (const variant of allResults) {
                console.log(`Processing variant: ${variant.name}`, variant.results);
                const results = variant.results;
                // Ensure std dev bars don't go outside min/max bounds
                const rangeMin = Math.max(results.min, Math.round(results.avg - results.stdDev));
                const rangeMax = Math.min(results.max, Math.round(results.avg + results.stdDev));
                
                // Calculate bar widths as percentages
                const minPercent = ((results.min - globalMin) / range) * 100;
                const maxPercent = ((results.max - globalMin) / range) * 100;
                const avgPercent = ((results.avg - globalMin) / range) * 100;
                const stdDevLeftPercent = ((rangeMin - globalMin) / range) * 100;
                const stdDevRightPercent = ((rangeMax - globalMin) / range) * 100;
                
                // Build missed bonus cards string
                let missedCardsInfo = '';
                if (results.successRate < 1 && results.missedBonusCards && Object.keys(results.missedBonusCards).length > 0) {
                    const missedEntries = Object.entries(results.missedBonusCards).sort((a, b) => b[1] - a[1]);
                    
                    const missedList = missedEntries
                        .slice(0, 3) // Show top 3
                        .map(([cardId, count]) => {
                            const bonus = techData.bonusTechs.find(t => t.id === cardId);
                            const percentage = Math.round((count / 1000) * 100); // Percentage of total runs
                            return `${bonus?.name || cardId} (${percentage}%)`;
                        });
                    missedCardsInfo = ` (failed: ${missedList.join(', ')})`;
                }
                
                html += `
                    <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                        <div style="color: #d4af37; font-weight: bold; margin-bottom: 4px; font-size: 0.95em;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <span>${variant.name} <span style="color: var(--primary-gold); font-weight: normal;">(±σ: ${Math.round(results.stdDev)})</span></span>
                                <div style="text-align: right;">
                                    <span style="color: ${results.successRate >= 0.95 ? 'var(--primary-green)' : results.successRate >= 0.8 ? 'var(--primary-gold)' : 'var(--light-red)'};">
                                        ${Math.round(results.successRate * 100)}% success${missedCardsInfo}
                                    </span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Bar chart with inline labels -->
                        <div style="position: relative; height: 45px; margin: 10px 0;">
                            <!-- Numbers positioned above the bar at their actual locations -->
                            ${(() => {
                                // Check for overlapping labels and only show distinct values
                                const labels = [
                                    { value: results.min, percent: minPercent, color: 'var(--primary-green)', type: 'min' },
                                    { value: Math.round(results.avg), percent: avgPercent, color: 'var(--light-blue)', type: 'avg' },
                                    { value: results.max, percent: maxPercent, color: 'var(--light-red)', type: 'max' }
                                ];
                                
                                // Sort by position
                                labels.sort((a, b) => a.percent - b.percent);
                                
                                let labelHtml = '';
                                const minSpacing = 5; // Minimum % spacing between labels
                                let lastShownLabel = null;
                                
                                for (let i = 0; i < labels.length; i++) {
                                    const label = labels[i];
                                    
                                    // Skip if too close to last shown label (within 5% and same value)
                                    if (lastShownLabel && 
                                        Math.abs(label.percent - lastShownLabel.percent) < minSpacing && 
                                        Math.abs(label.value - lastShownLabel.value) < 50) {
                                        continue; // Skip this label
                                    }
                                    
                                    labelHtml += `<div style="position: absolute; top: 0; left: ${label.percent}%; transform: translateX(-50%); color: ${label.color}; font-size: 0.75em; font-weight: bold;">
                                        ${label.value}
                                    </div>`;
                                    
                                    lastShownLabel = label;
                                }
                                
                                return labelHtml;
                            })()}
                            
                            <!-- Bar chart -->
                            <div style="position: absolute; top: 18px; width: 100%; height: 20px; background: rgba(0,0,0,0.5); border-radius: 10px; border: 1px solid #444;">
                                <!-- Min-Max range bar (light gray) -->
                                <div style="position: absolute; top: 6px; left: ${minPercent}%; width: ${maxPercent - minPercent}%; height: 8px; background: rgba(128,128,128,0.4); border-radius: 4px;"></div>
                                
                                <!-- StdDev range bar (gold) -->
                                <div style="position: absolute; top: 3px; left: ${stdDevLeftPercent}%; width: ${stdDevRightPercent - stdDevLeftPercent}%; height: 14px; background: var(--primary-gold); opacity: 0.6; border-radius: 7px;"></div>
                                
                                <!-- Average line (blue) -->
                                <div style="position: absolute; top: 2px; left: ${avgPercent}%; width: 3px; height: 16px; background: var(--light-blue); border-radius: 1px;"></div>
                                
                                <!-- Min marker (green) -->
                                <div style="position: absolute; top: 0; left: ${minPercent}%; width: 2px; height: 20px; background: var(--primary-green);"></div>
                                
                                <!-- Max marker (red) -->
                                <div style="position: absolute; top: 0; left: ${maxPercent}%; width: 2px; height: 20px; background: var(--light-red);"></div>
                            </div>
                            
                        </div>
                        
                    </div>
                `;
            }
            
            html += `
                <div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.75em; color: var(--text-muted); text-align: center;">
                    <strong>Legend:</strong> 
                    <span style="color: var(--primary-green);">Green</span> = Min | 
                    <span style="color: var(--light-blue);">Blue</span> = Average | 
                    <span style="color: var(--light-red);">Red</span> = Max | 
                    <span style="color: var(--primary-gold);">Gold bar</span> = ±1 Standard Deviation
                </div>
            `;
            container.innerHTML = html;
            
            // CRITICAL: Make sure the container itself is visible!
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.opacity = '1';
            
            console.log('Results displayed using div layout instead of table');
            console.log('Container display set to:', container.style.display);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            drawConnections();
        });

        // Initialize the tech tree when page loads
        window.addEventListener('load', initializeTechTree);
    </script>
</body>
</html>